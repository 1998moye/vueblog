/*!
* Vuetify v3.0.0-alpha.9
* Forged by John Leider
* Released under the MIT License.
*/     
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"));
	else if(typeof define === 'function' && define.amd)
		define(["vue"], factory);
	else if(typeof exports === 'object')
		exports["Vuetify"] = factory(require("vue"));
	else
		root["Vuetify"] = factory(root["Vue"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__982__) {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 982:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__982__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "createVuetify": () => (/* binding */ entry_bundler_createVuetify)
});

// NAMESPACE OBJECT: ./src/components/index.ts
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, {
  "VAlert": () => (VAlert),
  "VApp": () => (VApp),
  "VAppBar": () => (VAppBar),
  "VAppBarNavIcon": () => (VAppBarNavIcon),
  "VAppBarTitle": () => (VAppBarTitle),
  "VAvatar": () => (VAvatar),
  "VBadge": () => (VBadge),
  "VBanner": () => (VBanner),
  "VBannerActions": () => (VBannerActions),
  "VBannerAvatar": () => (VBannerAvatar),
  "VBannerContent": () => (VBannerContent),
  "VBannerText": () => (VBannerText),
  "VBottomNavigation": () => (VBottomNavigation),
  "VBreadcrumbs": () => (VBreadcrumbs),
  "VBreadcrumbsDivider": () => (VBreadcrumbsDivider),
  "VBreadcrumbsItem": () => (VBreadcrumbsItem),
  "VBtn": () => (VBtn),
  "VCard": () => (VCard),
  "VCardActions": () => (VCardActions),
  "VCardAvatar": () => (VCardAvatar),
  "VCardHeader": () => (VCardHeader),
  "VCardHeaderText": () => (VCardHeaderText),
  "VCardImg": () => (VCardImg),
  "VCardItem": () => (VCardHeaderText),
  "VCardMedia": () => (VCardMedia),
  "VCardSubtitle": () => (VCardSubtitle),
  "VCardText": () => (VCardText),
  "VCardTitle": () => (VCardTitle),
  "VCarouselReverseTransition": () => (VCarouselReverseTransition),
  "VCarouselTransition": () => (VCarouselTransition),
  "VChip": () => (VChip),
  "VClassIcon": () => (VClassIcon),
  "VCode": () => (VCode),
  "VCol": () => (VCol),
  "VComponentIcon": () => (VComponentIcon),
  "VContainer": () => (VContainer),
  "VDefaultsProvider": () => (VDefaultsProvider),
  "VDialog": () => (VDialog),
  "VDialogBottomTransition": () => (VDialogBottomTransition),
  "VDialogTopTransition": () => (VDialogTopTransition),
  "VDialogTransition": () => (dialog_transition),
  "VDivider": () => (VDivider),
  "VExpandTransition": () => (VExpandTransition),
  "VExpandXTransition": () => (VExpandXTransition),
  "VFabTransition": () => (VFabTransition),
  "VFadeTransition": () => (VFadeTransition),
  "VFooter": () => (VFooter),
  "VIcon": () => (VIcon),
  "VImg": () => (VImg),
  "VItem": () => (VItem),
  "VItemGroup": () => (VItemGroup),
  "VKbd": () => (VKbd),
  "VLayout": () => (VLayout),
  "VLayoutItem": () => (VLayoutItem),
  "VLazy": () => (VLazy),
  "VLigatureIcon": () => (VLigatureIcon),
  "VList": () => (VList),
  "VListImg": () => (VListImg),
  "VListItem": () => (VListItem),
  "VListItemAvatar": () => (VListItemAvatar),
  "VListItemHeader": () => (VListItemHeader),
  "VListItemMedia": () => (VListItemMedia),
  "VListItemSubtitle": () => (VListItemSubtitle),
  "VListItemTitle": () => (VListItemTitle),
  "VListSubheader": () => (VListSubheader),
  "VLocaleProvider": () => (VLocaleProvider),
  "VMain": () => (VMain),
  "VMenuTransition": () => (VMenuTransition),
  "VNavigationDrawer": () => (VNavigationDrawer),
  "VOverlay": () => (VOverlay),
  "VPagination": () => (VPagination),
  "VProgressCircular": () => (VProgressCircular),
  "VRating": () => (VRating),
  "VResponsive": () => (VResponsive),
  "VRow": () => (VRow),
  "VScaleTransition": () => (VScaleTransition),
  "VScrollXReverseTransition": () => (VScrollXReverseTransition),
  "VScrollXTransition": () => (VScrollXTransition),
  "VScrollYReverseTransition": () => (VScrollYReverseTransition),
  "VScrollYTransition": () => (VScrollYTransition),
  "VSheet": () => (VSheet),
  "VSlideXReverseTransition": () => (VSlideXReverseTransition),
  "VSlideXTransition": () => (VSlideXTransition),
  "VSlideYReverseTransition": () => (VSlideYReverseTransition),
  "VSlideYTransition": () => (VSlideYTransition),
  "VSpacer": () => (VSpacer),
  "VSvgIcon": () => (VSvgIcon),
  "VSystemBar": () => (VSystemBar),
  "VTabReverseTransition": () => (VTabReverseTransition),
  "VTabTransition": () => (VTabTransition),
  "VThemeProvider": () => (VThemeProvider),
  "VTimeline": () => (VTimeline),
  "VTimelineItem": () => (VTimelineItem)
});

// NAMESPACE OBJECT: ./src/directives/index.ts
var directives_namespaceObject = {};
__webpack_require__.r(directives_namespaceObject);
__webpack_require__.d(directives_namespaceObject, {
  "ClickOutside": () => (ClickOutside),
  "Intersect": () => (Intersect),
  "Resize": () => (Resize),
  "Ripple": () => (Ripple),
  "Scroll": () => (Scroll),
  "Touch": () => (Touch)
});

;// CONCATENATED MODULE: ./src/styles/main.sass
// extracted by mini-css-extract-plugin

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","amd":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_ = __webpack_require__(982);
;// CONCATENATED MODULE: ./src/components/VApp/VApp.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/util/propsFactory.ts
/**
 * Creates a factory function for props definitions.
 * This is used to define props in a composable then override
 * default values in an implementing component.
 *
 * @example Simplified signature
 * (props: Props) => (defaults?: Record<keyof props, any>) => Props
 *
 * @example Usage
 * const makeProps = propsFactory({
 *   foo: String,
 * })
 *
 * defineComponent({
 *   props: {
 *     ...makeProps({
 *       foo: 'a',
 *     }),
 *   },
 *   setup (props) {
 *     // would be "string | undefined", now "string" because a default has been provided
 *     props.foo
 *   },
 * }
 */
function propsFactory(props, source) {
  return defaults => {
    return Object.keys(props).reduce((obj, prop) => {
      const isObjectDefinition = typeof props[prop] === 'object' && props[prop] != null && !Array.isArray(props[prop]);
      const definition = isObjectDefinition ? props[prop] : {
        type: props[prop]
      };

      if (defaults && prop in defaults) {
        obj[prop] = { ...definition,
          default: defaults[prop]
        };
      } else {
        obj[prop] = definition;
      }

      if (source) {
        obj[prop].source = source;
      }

      return obj;
    }, {});
  };
}
;// CONCATENATED MODULE: ./src/util/helpers.ts

function getNestedValue(obj, path, fallback) {
  const last = path.length - 1;
  if (last < 0) return obj === undefined ? fallback : obj;

  for (let i = 0; i < last; i++) {
    if (obj == null) {
      return fallback;
    }

    obj = obj[path[i]];
  }

  if (obj == null) return fallback;
  return obj[path[last]] === undefined ? fallback : obj[path[last]];
}
function deepEqual(a, b) {
  if (a === b) return true;

  if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
    // If the values are Date, compare them as timestamps
    return false;
  }

  if (a !== Object(a) || b !== Object(b)) {
    // If the values aren't objects, they were already checked for equality
    return false;
  }

  const props = Object.keys(a);

  if (props.length !== Object.keys(b).length) {
    // Different number of props, don't bother to check
    return false;
  }

  return props.every(p => deepEqual(a[p], b[p]));
}
function getObjectValueByPath(obj, path, fallback) {
  // credit: http://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key#comment55278413_6491621
  if (obj == null || !path || typeof path !== 'string') return fallback;
  if (obj[path] !== undefined) return obj[path];
  path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties

  path = path.replace(/^\./, ''); // strip a leading dot

  return getNestedValue(obj, path.split('.'), fallback);
}
function getPropertyFromItem(item, property, fallback) {
  if (property == null) return item === undefined ? fallback : item;
  if (item !== Object(item)) return fallback === undefined ? item : fallback;
  if (typeof property === 'string') return getObjectValueByPath(item, property, fallback);
  if (Array.isArray(property)) return getNestedValue(item, property, fallback);
  if (typeof property !== 'function') return fallback;
  const value = property(item, fallback);
  return typeof value === 'undefined' ? fallback : value;
}
function createRange(length, start = 0) {
  return Array.from({
    length
  }, (v, k) => start + k);
}
function getZIndex(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE) return 0;
  const index = +window.getComputedStyle(el).getPropertyValue('z-index');
  if (!index) return getZIndex(el.parentNode);
  return index;
}
const tagsToReplace = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;'
};
function escapeHTML(str) {
  return str.replace(/[&<>]/g, tag => tagsToReplace[tag] || tag);
}
function filterObjectOnKeys(obj, keys) {
  const filtered = {};

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];

    if (typeof obj[key] !== 'undefined') {
      filtered[key] = obj[key];
    }
  }

  return filtered;
}
function convertToUnit(str, unit = 'px') {
  if (str == null || str === '') {
    return undefined;
  } else if (isNaN(+str)) {
    return String(str);
  } else {
    return `${Number(str)}${unit}`;
  }
}
function isObject(obj) {
  return obj !== null && typeof obj === 'object';
} // KeyboardEvent.keyCode aliases

const keyCodes = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
});
const keyValues = Object.freeze({
  enter: 'Enter',
  tab: 'Tab',
  delete: 'Delete',
  esc: 'Escape',
  space: 'Space',
  up: 'ArrowUp',
  down: 'ArrowDown',
  left: 'ArrowLeft',
  right: 'ArrowRight',
  end: 'End',
  home: 'Home',
  del: 'Delete',
  backspace: 'Backspace',
  insert: 'Insert',
  pageup: 'PageUp',
  pagedown: 'PageDown',
  shift: 'Shift'
});
function keys(o) {
  return Object.keys(o);
}
function extract(obj, properties) {
  const extracted = {};
  const rest = {};
  Object.entries(obj).forEach(([key, value]) => {
    if (properties.includes(key)) {
      extracted[key] = value;
    } else {
      rest[key] = value;
    }
  });
  return [extracted, rest];
}
/**
 * Returns the set difference of B and A, i.e. the set of elements in B but not in A
 */

function arrayDiff(a, b) {
  const diff = [];

  for (let i = 0; i < b.length; i++) {
    if (!a.includes(b[i])) diff.push(b[i]);
  }

  return diff;
}
function groupItems(items, groupBy, groupDesc) {
  const key = groupBy[0];
  const groups = [];
  let current;

  for (var i = 0; i < items.length; i++) {
    const item = items[i];
    const val = getObjectValueByPath(item, key, null);

    if (current !== val) {
      current = val;
      groups.push({
        name: val != null ? val : '',
        items: []
      });
    }

    groups[groups.length - 1].items.push(item);
  }

  return groups;
}
function wrapInArray(v) {
  return v == null ? [] : Array.isArray(v) ? v : [v];
}
function sortItems(items, sortBy, sortDesc, locale, customSorters) {
  if (sortBy === null || !sortBy.length) return items;
  const stringCollator = new Intl.Collator(locale, {
    sensitivity: 'accent',
    usage: 'sort'
  });
  return items.sort((a, b) => {
    for (let i = 0; i < sortBy.length; i++) {
      const sortKey = sortBy[i];
      let sortA = getObjectValueByPath(a, sortKey);
      let sortB = getObjectValueByPath(b, sortKey);

      if (sortDesc[i]) {
        [sortA, sortB] = [sortB, sortA];
      }

      if (customSorters != null && customSorters[sortKey]) {
        const customResult = customSorters[sortKey](sortA, sortB);
        if (!customResult) continue;
        return customResult;
      } // Check if both cannot be evaluated


      if (sortA === null && sortB === null) {
        continue;
      }

      [sortA, sortB] = [sortA, sortB].map(s => (s || '').toString().toLocaleLowerCase());

      if (sortA !== sortB) {
        if (!isNaN(sortA) && !isNaN(sortB)) return Number(sortA) - Number(sortB);
        return stringCollator.compare(sortA, sortB);
      }
    }

    return 0;
  });
}
function defaultFilter(value, search, item) {
  return value != null && search != null && typeof value !== 'boolean' && value.toString().toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) !== -1;
}
function searchItems(items, search) {
  if (!search) return items;
  search = search.toString().toLowerCase();
  if (search.trim() === '') return items;
  return items.filter(item => Object.keys(item).some(key => defaultFilter(getObjectValueByPath(item, key), search, item)));
}
function debounce(fn, delay) {
  let timeoutId = 0;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}
function throttle(fn, limit) {
  let throttling = false;
  return (...args) => {
    if (!throttling) {
      throttling = true;
      setTimeout(() => throttling = false, limit);
      return fn(...args);
    }
  };
}
/**
 * Filters slots to only those starting with `prefix`, removing the prefix
 */

function getPrefixedSlots(prefix, slots) {
  return Object.keys(slots).filter(k => k.startsWith(prefix)).reduce((obj, k) => {
    obj[k.replace(prefix, '')] = slots[k];
    return obj;
  }, {});
}
function clamp(value, min = 0, max = 1) {
  return Math.max(min, Math.min(max, value));
}
function helpers_padEnd(str, length, char = '0') {
  return str + char.repeat(Math.max(0, length - str.length));
}
function helpers_chunk(str, size = 1) {
  const chunked = [];
  let index = 0;

  while (index < str.length) {
    chunked.push(str.substr(index, size));
    index += size;
  }

  return chunked;
}
function humanReadableFileSize(bytes, binary = false) {
  const base = binary ? 1024 : 1000;

  if (bytes < base) {
    return `${bytes} B`;
  }

  const prefix = binary ? ['Ki', 'Mi', 'Gi'] : ['k', 'M', 'G'];
  let unit = -1;

  while (Math.abs(bytes) >= base && unit < prefix.length - 1) {
    bytes /= base;
    ++unit;
  }

  return `${bytes.toFixed(1)} ${prefix[unit]}B`;
}
function camelizeObjectKeys(obj) {
  if (!obj) return {};
  return Object.keys(obj).reduce((o, key) => {
    o[camelize(key)] = obj[key];
    return o;
  }, {});
}
function mergeDeep(source = {}, target = {}) {
  for (const key in target) {
    const sourceProperty = source[key];
    const targetProperty = target[key]; // Only continue deep merging if
    // both properties are objects

    if (isObject(sourceProperty) && isObject(targetProperty)) {
      source[key] = mergeDeep(sourceProperty, targetProperty);
      continue;
    }

    source[key] = targetProperty;
  }

  return source;
}
function fillArray(length, obj) {
  return Array(length).fill(obj);
}
function getUid() {
  return getUid._uid++;
}
getUid._uid = 0;
function flattenFragments(nodes) {
  return nodes.map(node => {
    if (node.type === external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Fragment) {
      return flattenFragments(node.children);
    } else {
      return node;
    }
  }).flat();
}
const randomHexColor = () => {
  const n = (Math.random() * 0xfffff * 1000000).toString(16);
  return '#' + n.slice(0, 6);
};
const toKebabCase = str => str.replace(/([A-Z])/g, match => `-${match.toLowerCase()}`);
function wrapInRef(x) {
  return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.isRef)(x) ? x : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(x);
}
;// CONCATENATED MODULE: ./src/util/console.ts
/* eslint-disable no-console */
// import Vuetify from '../framework'
function createMessage(message, vm, parent) {
  // if (Vuetify.config.silent) return
  if (parent) {
    vm = {
      _isVue: true,
      $parent: parent,
      $options: vm
    };
  }

  if (vm) {
    // Only show each message once per instance
    vm.$_alreadyWarned = vm.$_alreadyWarned || [];
    if (vm.$_alreadyWarned.includes(message)) return;
    vm.$_alreadyWarned.push(message);
  }

  return `[Vuetify] ${message}` + (vm ? generateComponentTrace(vm) : '');
}

function consoleInfo(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.info(newMessage);
}
function consoleWarn(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.warn(newMessage);
}
function consoleError(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.error(newMessage);
}
function deprecate(original, replacement, vm, parent) {
  consoleWarn(`[UPGRADE] '${original}' is deprecated, use '${replacement}' instead.`, vm, parent);
}
function breaking(original, replacement, vm, parent) {
  consoleError(`[BREAKING] '${original}' has been removed, use '${replacement}' instead. For more information, see the upgrade guide https://github.com/vuetifyjs/vuetify/releases/tag/v2.0.0#user-content-upgrade-guide`, vm, parent);
}
function removed(original, vm, parent) {
  consoleWarn(`[REMOVED] '${original}' has been removed. You can safely omit it.`, vm, parent);
}
/**
 * Shamelessly stolen from vuejs/vue/blob/dev/src/core/util/debug.js
 */

const classifyRE = /(?:^|[-_])(\w)/g;

const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');

function formatComponentName(vm, includeFile) {
  if (vm.$root === vm) {
    return '<Root>';
  }

  const options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
  let name = options.name || options._componentTag;
  const file = options.__file;

  if (!name && file) {
    const match = file.match(/([^/\\]+)\.vue$/);
    name = match == null ? void 0 : match[1];
  }

  return (name ? `<${classify(name)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : '');
}

function generateComponentTrace(vm) {
  if (vm._isVue && vm.$parent) {
    const tree = [];
    let currentRecursiveSequence = 0;

    while (vm) {
      if (tree.length > 0) {
        const last = tree[tree.length - 1];

        if (last.constructor === vm.constructor) {
          currentRecursiveSequence++;
          vm = vm.$parent;
          continue;
        } else if (currentRecursiveSequence > 0) {
          tree[tree.length - 1] = [last, currentRecursiveSequence];
          currentRecursiveSequence = 0;
        }
      }

      tree.push(vm);
      vm = vm.$parent;
    }

    return '\n\nfound in\n\n' + tree.map((vm, i) => `${i === 0 ? '---> ' : ' '.repeat(5 + i * 2)}${Array.isArray(vm) ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)` : formatComponentName(vm)}`).join('\n');
  } else {
    return `\n\n(found in ${formatComponentName(vm)})`;
  }
}
;// CONCATENATED MODULE: ./src/util/color/transformSRGB.ts
 // For converting XYZ to sRGB

const srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.2040, 1.0570]]; // Forward gamma adjust

const srgbForwardTransform = C => C <= 0.0031308 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055; // For converting sRGB to XYZ


const srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]]; // Reverse gamma adjust

const srgbReverseTransform = C => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;

function fromXYZ(xyz) {
  const rgb = Array(3);
  const transform = srgbForwardTransform;
  const matrix = srgbForwardMatrix; // Matrix transform, then gamma adjustment

  for (let i = 0; i < 3; ++i) {
    rgb[i] = Math.round(clamp(transform(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);
  } // Rescale back to [0, 255]


  return (rgb[0] << 16) + (rgb[1] << 8) + (rgb[2] << 0);
}
function toXYZ(rgb) {
  const xyz = [0, 0, 0];
  const transform = srgbReverseTransform;
  const matrix = srgbReverseMatrix; // Rescale from [0, 255] to [0, 1] then adjust sRGB gamma to linear RGB

  const r = transform((rgb >> 16 & 0xff) / 255);
  const g = transform((rgb >> 8 & 0xff) / 255);
  const b = transform((rgb >> 0 & 0xff) / 255); // Matrix color space transform

  for (let i = 0; i < 3; ++i) {
    xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b;
  }

  return xyz;
}
;// CONCATENATED MODULE: ./src/util/color/transformCIELAB.ts
const delta = 0.20689655172413793; // 6÷29

const cielabForwardTransform = t => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;

const cielabReverseTransform = t => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);

function transformCIELAB_fromXYZ(xyz) {
  const transform = cielabForwardTransform;
  const transformedY = transform(xyz[1]);
  return [116 * transformedY - 16, 500 * (transform(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform(xyz[2] / 1.08883))];
}
function transformCIELAB_toXYZ(lab) {
  const transform = cielabReverseTransform;
  const Ln = (lab[0] + 16) / 116;
  return [transform(Ln + lab[1] / 500) * 0.95047, transform(Ln), transform(Ln - lab[2] / 200) * 1.08883];
}
;// CONCATENATED MODULE: ./src/util/colorUtils.ts
// Utilities



 // Types

function isCssColor(color) {
  return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
}
function colorToInt(color) {
  let rgb;

  if (typeof color === 'number') {
    rgb = color;
  } else if (typeof color === 'string') {
    let c = color.startsWith('#') ? color.substring(1) : color;

    if (c.length === 3) {
      c = c.split('').map(char => char + char).join('');
    }

    if (c.length !== 6) {
      consoleWarn(`'${color}' is not a valid rgb color`);
    }

    rgb = parseInt(c, 16);
  } else {
    throw new TypeError(`Colors can only be numbers or strings, recieved ${color == null ? color : color.constructor.name} instead`);
  }

  if (rgb < 0) {
    consoleWarn(`Colors cannot be negative: '${color}'`);
    rgb = 0;
  } else if (rgb > 0xffffff || isNaN(rgb)) {
    consoleWarn(`'${color}' is not a valid rgb color`);
    rgb = 0xffffff;
  }

  return rgb;
}
function classToHex(color, colors, currentTheme) {
  const [colorName, colorModifier] = color.toString().trim().replace('-', '').split(' ', 2);
  let hexColor = '';

  if (colorName && colorName in colors) {
    if (colorModifier && colorModifier in colors[colorName]) {
      hexColor = colors[colorName][colorModifier];
    } else if ('base' in colors[colorName]) {
      hexColor = colors[colorName].base;
    }
  } else if (colorName && colorName in currentTheme) {
    hexColor = currentTheme[colorName];
  }

  return hexColor;
}
function intToHex(color) {
  let hexColor = color.toString(16);
  if (hexColor.length < 6) hexColor = '0'.repeat(6 - hexColor.length) + hexColor;
  return '#' + hexColor;
}
function colorToHex(color) {
  return intToHex(colorToInt(color));
}
/**
 * Converts HSVA to RGBA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV
 *
 * @param color HSVA color as an array [0-360, 0-1, 0-1, 0-1]
 */

function HSVAtoRGBA(hsva) {
  const {
    h,
    s,
    v,
    a
  } = hsva;

  const f = n => {
    const k = (n + h / 60) % 6;
    return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  };

  const rgb = [f(5), f(3), f(1)].map(v => Math.round(v * 255));
  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2],
    a
  };
}
/**
 * Converts RGBA to HSVA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV
 *
 * @param color RGBA color as an array [0-255, 0-255, 0-255, 0-1]
 */

function RGBAtoHSVA(rgba) {
  if (!rgba) return {
    h: 0,
    s: 1,
    v: 1,
    a: 1
  };
  const r = rgba.r / 255;
  const g = rgba.g / 255;
  const b = rgba.b / 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;

  if (max !== min) {
    if (max === r) {
      h = 60 * (0 + (g - b) / (max - min));
    } else if (max === g) {
      h = 60 * (2 + (b - r) / (max - min));
    } else if (max === b) {
      h = 60 * (4 + (r - g) / (max - min));
    }
  }

  if (h < 0) h = h + 360;
  const s = max === 0 ? 0 : (max - min) / max;
  const hsv = [h, s, max];
  return {
    h: hsv[0],
    s: hsv[1],
    v: hsv[2],
    a: rgba.a
  };
}
function HSVAtoHSLA(hsva) {
  const {
    h,
    s,
    v,
    a
  } = hsva;
  const l = v - v * s / 2;
  const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
  return {
    h,
    s: sprime,
    l,
    a
  };
}
function HSLAtoHSVA(hsl) {
  const {
    h,
    s,
    l,
    a
  } = hsl;
  const v = l + s * Math.min(l, 1 - l);
  const sprime = v === 0 ? 0 : 2 - 2 * l / v;
  return {
    h,
    s: sprime,
    v,
    a
  };
}
function RGBAtoCSS(rgba) {
  return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
}
function RGBtoCSS(rgba) {
  return RGBAtoCSS({ ...rgba,
    a: 1
  });
}
function RGBAtoHex(rgba) {
  const toHex = v => {
    const h = Math.round(v).toString(16);
    return ('00'.substr(0, 2 - h.length) + h).toUpperCase();
  };

  return `#${[toHex(rgba.r), toHex(rgba.g), toHex(rgba.b), toHex(Math.round(rgba.a * 255))].join('')}`;
}
function HexToRGBA(hex) {
  const rgba = chunk(hex.slice(1), 2).map(c => parseInt(c, 16));
  return {
    r: rgba[0],
    g: rgba[1],
    b: rgba[2],
    a: Math.round(rgba[3] / 255 * 100) / 100
  };
}
function HexToHSVA(hex) {
  const rgb = HexToRGBA(hex);
  return RGBAtoHSVA(rgb);
}
function HSVAtoHex(hsva) {
  return RGBAtoHex(HSVAtoRGBA(hsva));
}
function parseHex(hex) {
  if (hex.startsWith('#')) {
    hex = hex.slice(1);
  }

  hex = hex.replace(/([^0-9a-f])/gi, 'F');

  if (hex.length === 3 || hex.length === 4) {
    hex = hex.split('').map(x => x + x).join('');
  }

  if (hex.length === 6) {
    hex = padEnd(hex, 8, 'F');
  } else {
    hex = padEnd(padEnd(hex, 6), 8, 'F');
  }

  return `#${hex}`.toUpperCase().substr(0, 9);
}
function parseGradient(gradient, colors, currentTheme) {
  return gradient.replace(/([a-z]+(\s[a-z]+-[1-5])?)(?=$|,)/gi, x => {
    return classToHex(x, colors, currentTheme) || x;
  }).replace(/(rgba\()#[0-9a-f]+(?=,)/gi, x => {
    return 'rgba(' + Object.values(HexToRGBA(parseHex(x.replace(/rgba\(/, '')))).slice(0, 3).join(',');
  });
}
function RGBtoInt(rgba) {
  return (rgba.r << 16) + (rgba.g << 8) + rgba.b;
}
function colorToRGB(color) {
  const int = colorToInt(color);
  return {
    r: (int & 0xFF0000) >> 16,
    g: (int & 0xFF00) >> 8,
    b: int & 0xFF
  };
}
function lighten(value, amount) {
  const lab = transformCIELAB_fromXYZ(toXYZ(value)); // TODO: why this false positive?
  // eslint-disable-next-line @typescript-eslint/restrict-plus-operands

  lab[0] = lab[0] + amount * 10;
  return fromXYZ(transformCIELAB_toXYZ(lab));
}
function darken(value, amount) {
  const lab = transformCIELAB_fromXYZ(toXYZ(value));
  lab[0] = lab[0] - amount * 10;
  return fromXYZ(transformCIELAB_toXYZ(lab));
}
/**
 * Calculate the relative luminance of a given color
 * @see https://www.w3.org/TR/WCAG20/#relativeluminancedef
 */

function getLuma(color) {
  const rgb = colorToInt(color);
  return toXYZ(rgb)[1];
}
/**
 * Returns the contrast ratio (1-21) between two colors.
 * @see https://www.w3.org/TR/WCAG20/#contrast-ratiodef
 */

function getContrast(first, second) {
  const l1 = getLuma(first);
  const l2 = getLuma(second);
  const light = Math.max(l1, l2);
  const dark = Math.min(l1, l2);
  return (light + 0.05) / (dark + 0.05);
}
;// CONCATENATED MODULE: ./src/util/color/APCA.ts
/**
 * WCAG 3.0 APCA perceptual contrast algorithm from https://github.com/Myndex/SAPC-APCA
 * @licence https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @see https://www.w3.org/WAI/GL/task-forces/silver/wiki/Visual_Contrast_of_Text_Subgroup
 */
// MAGICAL NUMBERS
// sRGB Conversion to Relative Luminance (Y)
// Transfer Curve (aka "Gamma") for sRGB linearization
// Simple power curve vs piecewise described in docs
// Essentially, 2.4 best models actual display
// characteristics in combination with the total method
const mainTRC = 2.4;
const Rco = 0.2126729; // sRGB Red Coefficient (from matrix)

const Gco = 0.7151522; // sRGB Green Coefficient (from matrix)

const Bco = 0.0721750; // sRGB Blue Coefficient (from matrix)
// For Finding Raw SAPC Contrast from Relative Luminance (Y)
// Constants for SAPC Power Curve Exponents
// One pair for normal text, and one for reverse
// These are the "beating heart" of SAPC

const normBG = 0.55;
const normTXT = 0.58;
const revTXT = 0.57;
const revBG = 0.62; // For Clamping and Scaling Values

const blkThrs = 0.03; // Level that triggers the soft black clamp

const blkClmp = 1.45; // Exponent for the soft black clamp curve

const deltaYmin = 0.0005; // Lint trap

const scaleBoW = 1.25; // Scaling for dark text on light

const scaleWoB = 1.25; // Scaling for light text on dark

const loConThresh = 0.078; // Threshold for new simple offset scale

const loConFactor = 12.82051282051282; // = 1/0.078,

const loConOffset = 0.06; // The simple offset

const loClip = 0.001; // Output clip (lint trap #2)

function APCAcontrast(text, background) {
  // Linearize sRGB
  const Rtxt = ((text >> 16 & 0xff) / 255) ** mainTRC;
  const Gtxt = ((text >> 8 & 0xff) / 255) ** mainTRC;
  const Btxt = ((text >> 0 & 0xff) / 255) ** mainTRC;
  const Rbg = ((background >> 16 & 0xff) / 255) ** mainTRC;
  const Gbg = ((background >> 8 & 0xff) / 255) ** mainTRC;
  const Bbg = ((background >> 0 & 0xff) / 255) ** mainTRC; // Apply the standard coefficients and sum to Y

  let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
  let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco; // Soft clamp Y when near black.
  // Now clamping all colors to prevent crossover errors

  if (Ytxt <= blkThrs) Ytxt += (blkThrs - Ytxt) ** blkClmp;
  if (Ybg <= blkThrs) Ybg += (blkThrs - Ybg) ** blkClmp; // Return 0 Early for extremely low ∆Y (lint trap #1)

  if (Math.abs(Ybg - Ytxt) < deltaYmin) return 0.0; // SAPC CONTRAST

  let outputContrast; // For weighted final values

  if (Ybg > Ytxt) {
    // For normal polarity, black text on white
    // Calculate the SAPC contrast value and scale
    const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW; // NEW! SAPC SmoothScale™
    // Low Contrast Smooth Scale Rollout to prevent polarity reversal
    // and also a low clip for very low contrasts (lint trap #2)
    // much of this is for very low contrasts, less than 10
    // therefore for most reversing needs, only loConOffset is important

    outputContrast = SAPC < loClip ? 0.0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
  } else {
    // For reverse polarity, light text on dark
    // WoB should always return negative value.
    const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
    outputContrast = SAPC > -loClip ? 0.0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
  }

  return outputContrast * 100;
}
;// CONCATENATED MODULE: ./src/composables/theme.ts
 // Utilities

 // Types



const ThemeSymbol = Symbol.for('vuetify:theme');
const makeThemeProps = propsFactory({
  theme: String
}, 'theme');
const defaultThemeOptions = {
  defaultTheme: 'light',
  variations: {
    colors: [],
    lighten: 0,
    darken: 0
  },
  themes: {
    light: {
      dark: false,
      colors: {
        background: '#FFFFFF',
        surface: '#FFFFFF',
        primary: '#6200EE',
        'primary-darken-1': '#3700B3',
        secondary: '#03DAC6',
        'secondary-darken-1': '#018786',
        error: '#B00020',
        info: '#2196F3',
        success: '#4CAF50',
        warning: '#FB8C00'
      },
      variables: {
        'border-color': '#000000',
        'border-opacity': 0.12,
        'high-emphasis-opacity': 0.87,
        'medium-emphasis-opacity': 0.60,
        'disabled-opacity': 0.38,
        'activated-opacity': 0.12,
        'hover-opacity': 0.04,
        'focus-opacity': 0.12,
        'selected-opacity': 0.08,
        'dragged-opacity': 0.08,
        'pressed-opacity': 0.16,
        'kbd-background-color': '#212529',
        'kbd-color': '#FFFFFF',
        'code-background-color': '#C2C2C2'
      }
    },
    dark: {
      dark: true,
      colors: {
        background: '#121212',
        surface: '#212121',
        primary: '#BB86FC',
        'primary-darken-1': '#3700B3',
        secondary: '#03DAC5',
        'secondary-darken-1': '#03DAC5',
        error: '#CF6679',
        info: '#2196F3',
        success: '#4CAF50',
        warning: '#FB8C00'
      },
      variables: {
        'border-color': '#FFFFFF',
        'border-opacity': 0.12,
        'high-emphasis-opacity': 0.87,
        'medium-emphasis-opacity': 0.60,
        'disabled-opacity': 0.38,
        'activated-opacity': 0.12,
        'hover-opacity': 0.04,
        'focus-opacity': 0.12,
        'selected-opacity': 0.08,
        'dragged-opacity': 0.08,
        'pressed-opacity': 0.16,
        'kbd-background-color': '#212529',
        'kbd-color': '#FFFFFF',
        'code-background-color': '#B7B7B7'
      }
    }
  }
};

const parseThemeOptions = (options = defaultThemeOptions) => {
  if (!options) return { ...defaultThemeOptions,
    isDisabled: true
  };
  return mergeDeep(defaultThemeOptions, options);
}; // Composables


function createTheme(options) {
  const parsedOptions = parseThemeOptions(options);
  const styleEl = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
  const current = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(parsedOptions.defaultTheme);
  const themes = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(parsedOptions.themes);
  const variations = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(parsedOptions.variations);
  const computedThemes = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    return Object.keys(themes.value).reduce((obj, key) => {
      var _parsedOptions$variat;

      const theme = { ...themes.value[key],
        colors: { ...themes.value[key].colors,
          ...((_parsedOptions$variat = parsedOptions.variations.colors) != null ? _parsedOptions$variat : []).reduce((obj, color) => {
            return { ...obj,
              ...genColorVariations(color, themes.value[key].colors[color])
            };
          }, {})
        }
      };

      for (const color of Object.keys(theme.colors)) {
        if (/on-[a-z]/.test(color) || theme.colors[`on-${color}`]) continue;
        const onColor = `on-${color}`;
        const colorVal = colorToInt(theme.colors[color]);
        const blackContrast = Math.abs(APCAcontrast(0, colorVal));
        const whiteContrast = Math.abs(APCAcontrast(0xffffff, colorVal)); // TODO: warn about poor color selections
        // const contrastAsText = Math.abs(APCAcontrast(colorVal, colorToInt(theme.colors.background)))
        // const minContrast = Math.max(blackContrast, whiteContrast)
        // if (minContrast < 60) {
        //   consoleInfo(`${key} theme color ${color} has poor contrast (${minContrast.toFixed()}%)`)
        // } else if (contrastAsText < 60 && !['background', 'surface'].includes(color)) {
        //   consoleInfo(`${key} theme color ${color} has poor contrast as text (${contrastAsText.toFixed()}%)`)
        // }
        // Prefer white text if both have an acceptable contrast ratio

        theme.colors[onColor] = whiteContrast > Math.min(blackContrast, 50) ? '#fff' : '#000';
      }

      obj[key] = theme;
      return obj;
    }, {});
  });

  function genColorVariations(name, color) {
    const obj = {};

    for (const variation of ['lighten', 'darken']) {
      const fn = variation === 'lighten' ? lighten : darken;

      for (const amount of createRange(variations.value[variation], 1)) {
        obj[`${name}-${variation}-${amount}`] = intToHex(fn(colorToInt(color), amount));
      }
    }

    return obj;
  }

  function genCssVariables(name) {
    const theme = computedThemes.value[name];
    if (!theme) throw new Error(`Could not find theme ${name}`);
    const lightOverlay = theme.dark ? 2 : 1;
    const darkOverlay = theme.dark ? 1 : 2;
    const variables = [];

    for (const [key, value] of Object.entries(theme.colors)) {
      const rgb = colorToRGB(value);
      variables.push(`--v-theme-${key}: ${rgb.r},${rgb.g},${rgb.b}`);

      if (!key.startsWith('on-')) {
        variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
      }
    }

    return variables;
  }

  function genStyleElement() {
    if (typeof document === 'undefined' || styleEl.value) return;
    const el = document.createElement('style');
    el.type = 'text/css';
    el.id = 'vuetify-theme-stylesheet';
    styleEl.value = el;
    document.head.appendChild(styleEl.value);
  }

  function createCssClass(selector, content) {
    return [`${selector} {\n`, ...content.map(line => `  ${line};\n`), '}\n'];
  }

  function updateStyles() {
    if (parsedOptions.isDisabled) return;
    genStyleElement();
    const lines = [];

    for (const themeName of Object.keys(computedThemes.value)) {
      const variables = computedThemes.value[themeName].variables;
      lines.push(...createCssClass(`.v-theme--${themeName}`, [...genCssVariables(themeName), ...Object.keys(variables).map(key => {
        const value = variables[key];
        const color = typeof value === 'string' && value.startsWith('#') ? colorToRGB(value) : undefined;
        const rgb = color ? `${color.r}, ${color.g}, ${color.b}` : undefined;
        return `--v-${key}: ${rgb != null ? rgb : value}`;
      })]));
    } // Assumption is that all theme objects have the same keys, so it doesn't matter which one
    // we use since the values are all css variables.


    const firstTheme = Object.keys(computedThemes.value)[0];

    for (const key of Object.keys(computedThemes.value[firstTheme].colors)) {
      if (/on-[a-z]/.test(key)) {
        lines.push(...createCssClass(`.${key}`, [`color: rgb(var(--v-theme-${key}))`]));
      } else {
        lines.push(...createCssClass(`.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background: rgb(var(--v-theme-${key}))`, `color: rgb(var(--v-theme-on-${key}))`]), ...createCssClass(`.text-${key}`, [`color: rgb(var(--v-theme-${key}))`]), ...createCssClass(`.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]));
      }
    }

    if (styleEl.value) styleEl.value.innerHTML = lines.map((str, i) => i === 0 ? str : `    ${str}`).join('');
  }

  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(themes, updateStyles, {
    deep: true,
    immediate: true
  });
  return {
    isDisabled: parsedOptions.isDisabled,
    themes: computedThemes,
    setTheme: (key, theme) => themes.value[key] = theme,
    getTheme: key => computedThemes.value[key],
    current,
    themeClasses: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => parsedOptions.isDisabled ? undefined : `v-theme--${current.value}`)
  };
}
/**
 * Used to either set up and provide a new theme instance, or to pass
 * along the closest available already provided instance.
 */

function useTheme(props) {
  const vm = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.getCurrentInstance)();
  const theme = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(ThemeSymbol, null);
  if (!vm) consoleError('provideTheme must be called from inside a setup function');
  if (!theme) throw new Error('Could not find Vuetify theme injection');
  const current = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    var _props$theme;

    return (_props$theme = props.theme) != null ? _props$theme : theme == null ? void 0 : theme.current.value;
  });
  const themeClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => theme.isDisabled ? undefined : `v-theme--${current.value}`);
  const newTheme = { ...theme,
    current,
    themeClasses
  };
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.provide)(ThemeSymbol, newTheme);
  return newTheme;
}
;// CONCATENATED MODULE: ./src/composables/layout.ts
// Utilities

 // Types

const VuetifyLayoutKey = Symbol.for('vuetify:layout');
const makeLayoutProps = propsFactory({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, 'layout'); // Composables

const makeLayoutItemProps = propsFactory({
  name: {
    type: String
  },
  priority: {
    type: Number,
    default: 0
  },
  absolute: Boolean
}, 'layout-item');
function useMain() {
  const layout = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(VuetifyLayoutKey);
  if (!layout) throw new Error('Could not find injected Vuetify layout');
  return layout;
}
function useLayoutItem(name, priority, position, layoutSize, elementSize, active) {
  const layout = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(VuetifyLayoutKey);
  if (!layout) throw new Error('Could not find injected Vuetify layout');
  const id = name != null ? name : `layout-item-${getUid()}`;
  const styles = layout.register(id, priority, position, layoutSize, elementSize, active);
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeUnmount)(() => layout.unregister(id));
  return styles;
}

const generateLayers = (layout, registered, positions, layoutSizes, activeItems) => {
  let previousLayer = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const layers = [{
    id: '',
    layer: { ...previousLayer
    }
  }];
  const ids = !layout.length ? registered : layout.map(l => l.split(':')[0]).filter(l => registered.includes(l));

  for (const id of ids) {
    const position = positions.get(id);
    const amount = layoutSizes.get(id);
    const active = activeItems.get(id);
    if (!position || !amount || !active) continue;
    const layer = { ...previousLayer,
      [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
    };
    layers.push({
      id,
      layer
    });
    previousLayer = layer;
  }

  return layers;
}; // TODO: Remove undefined from layout and overlaps when vue typing for required: true prop is fixed


function createLayout(props) {
  const registered = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)([]);
  const positions = new Map();
  const layoutSizes = new Map();
  const priorities = new Map();
  const activeItems = new Map();
  const computedOverlaps = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    var _props$overlaps;

    const map = new Map();
    const overlaps = (_props$overlaps = props.overlaps) != null ? _props$overlaps : [];

    for (const overlap of overlaps.filter(item => item.includes(':'))) {
      const [top, bottom] = overlap.split(':');
      if (!registered.value.includes(top) || !registered.value.includes(bottom)) continue;
      const topPosition = positions.get(top);
      const bottomPosition = positions.get(bottom);
      const topAmount = layoutSizes.get(top);
      const bottomAmount = layoutSizes.get(bottom);
      if (!topPosition || !bottomPosition || !topAmount || !bottomAmount) continue;
      map.set(bottom, {
        position: topPosition.value,
        amount: parseInt(topAmount.value, 10)
      });
      map.set(top, {
        position: bottomPosition.value,
        amount: -parseInt(bottomAmount.value, 10)
      });
    }

    return map;
  });
  const layers = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const entries = [...priorities.entries()];
    const sortedEntries = entries.sort(([, a], [, b]) => a.value - b.value).map(([id]) => id);
    return generateLayers(sortedEntries, registered.value, positions, layoutSizes, activeItems);
  });
  const mainStyles = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const layer = layers.value[layers.value.length - 1].layer;
    return {
      position: 'relative',
      paddingLeft: convertToUnit(layer.left),
      paddingRight: convertToUnit(layer.right),
      paddingTop: convertToUnit(layer.top),
      paddingBottom: convertToUnit(layer.bottom)
    };
  });
  const items = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    return layers.value.slice(1).map(({
      id
    }, index) => {
      const {
        layer
      } = layers.value[index];
      const size = layoutSizes.get(id);
      return {
        id,
        ...layer,
        size: Number(size.value)
      };
    });
  });

  const getLayoutItem = id => {
    return items.value.find(item => item.id === id);
  };

  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.provide)(VuetifyLayoutKey, {
    register: (id, priority, position, layoutSize, elementSize, active) => {
      priorities.set(id, priority);
      positions.set(id, position);
      layoutSizes.set(id, layoutSize);
      activeItems.set(id, active);
      registered.value.push(id);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
        const index = items.value.findIndex(i => i.id === id);
        if (index < 0) throw new Error(`Layout item "${id}" is missing from layout prop`);
        const item = items.value[index];
        if (!item) throw new Error(`Could not find layout item "${id}`);
        const overlap = computedOverlaps.value.get(id);

        if (overlap) {
          item[overlap.position] += overlap.amount;
        }

        const isHorizontal = position.value === 'left' || position.value === 'right';
        const isOppositeHorizontal = position.value === 'right';
        const isOppositeVertical = position.value === 'bottom';
        return {
          [position.value]: 0,
          height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : `${elementSize.value}px`,
          marginLeft: isOppositeHorizontal ? undefined : `${item.left}px`,
          marginRight: isOppositeHorizontal ? `${item.right}px` : undefined,
          marginTop: position.value !== 'bottom' ? `${item.top}px` : undefined,
          marginBottom: position.value !== 'top' ? `${item.bottom}px` : undefined,
          width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : `${elementSize.value}px`,
          zIndex: layers.value.length - index,
          transform: `translate${isHorizontal ? 'X' : 'Y'}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`
        };
      });
    },
    unregister: id => {
      priorities.delete(id);
      positions.delete(id);
      layoutSizes.delete(id);
      activeItems.delete(id);
      registered.value = registered.value.filter(v => v !== id);
    },
    mainStyles,
    getLayoutItem,
    items
  });
  const layoutClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => ['v-layout', {
    'v-layout--full-height': props.fullHeight
  }]);
  return {
    layoutClasses,
    getLayoutItem,
    items
  };
}
;// CONCATENATED MODULE: ./src/composables/defaults.ts


const DefaultsSymbol = Symbol.for('vuetify:defaults');
function createDefaults(options) {
  return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(options != null ? options : {});
}
function useDefaults() {
  const defaults = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(DefaultsSymbol);
  if (!defaults) throw new Error('[Vuetify] Could not find defaults instance');
  return defaults;
}
function provideDefaults(props) {
  const defaults = useDefaults();
  const newDefaults = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => mergeDeep(defaults.value, props == null ? void 0 : props.defaults));
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.provide)(DefaultsSymbol, newDefaults);
  return newDefaults;
}
;// CONCATENATED MODULE: ./src/util/defineComponent.tsx
// Utils



 // Types

function propIsDefined(vnode, prop) {
  var _vnode$props, _vnode$props2;

  return ((_vnode$props = vnode.props) == null ? void 0 : _vnode$props.hasOwnProperty(prop)) || ((_vnode$props2 = vnode.props) == null ? void 0 : _vnode$props2.hasOwnProperty(toKebabCase(prop)));
}

const defineComponent = function defineComponent(options) {
  const _setup = options.setup;

  if (!options.name) {
    consoleWarn('The component is missing an explicit name, unable to generate default prop value');
    return options;
  }

  if (_setup) {
    options.setup = function setup(props, ctx) {
      const vm = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.getCurrentInstance)();
      const defaults = useDefaults();

      const _props = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.shallowReactive)({ ...(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRaw)(props)
      });

      (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watchEffect)(() => {
        const globalDefaults = defaults.value.global;
        const componentDefaults = defaults.value[options.name];

        for (const prop of Object.keys(props)) {
          let newVal;

          if (propIsDefined(vm.vnode, prop)) {
            newVal = props[prop];
          } else {
            var _ref, _componentDefaults$pr;

            newVal = (_ref = (_componentDefaults$pr = componentDefaults == null ? void 0 : componentDefaults[prop]) != null ? _componentDefaults$pr : globalDefaults == null ? void 0 : globalDefaults[prop]) != null ? _ref : props[prop];
          }

          if (_props[prop] !== newVal) {
            _props[prop] = newVal;
          }
        }
      });
      return _setup(_props, ctx);
    };
  }

  return options;
};
;// CONCATENATED MODULE: ./src/locale/index.ts










































const rtl = {
  af: false,
  ar: true,
  bg: false,
  ca: false,
  ckb: false,
  cs: false,
  de: false,
  el: false,
  en: false,
  es: false,
  et: false,
  fa: false,
  fi: false,
  fr: false,
  hr: false,
  hu: false,
  he: true,
  id: false,
  it: false,
  ja: false,
  ko: false,
  lv: false,
  lt: false,
  nl: false,
  no: false,
  pl: false,
  pt: false,
  ro: false,
  ru: false,
  sk: false,
  sl: false,
  srCyrl: false,
  srLatn: false,
  sv: false,
  th: false,
  tr: false,
  az: false,
  uk: false,
  vi: false,
  zhHans: false,
  zhHant: false
};
;// CONCATENATED MODULE: ./src/composables/rtl.ts

 // Types

const RtlSymbol = Symbol.for('vuetify:rtl');
function createRtl(localeScope, options) {
  var _options$rtl, _options$defaultRtl;

  return createRtlScope({
    rtl: { ...rtl,
      ...((_options$rtl = options == null ? void 0 : options.rtl) != null ? _options$rtl : {})
    },
    isRtl: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)((_options$defaultRtl = options == null ? void 0 : options.defaultRtl) != null ? _options$defaultRtl : false),
    rtlClasses: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)('')
  }, localeScope);
}
function createRtlScope(currentScope, localeScope, options) {
  const isRtl = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    if (typeof (options == null ? void 0 : options.rtl) === 'boolean') return options.rtl;

    if (localeScope.current.value && currentScope.rtl.hasOwnProperty(localeScope.current.value)) {
      return currentScope.rtl[localeScope.current.value];
    }

    return currentScope.isRtl.value;
  });
  return {
    isRtl,
    rtl: currentScope.rtl,
    rtlClasses: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => `v-locale--is-${isRtl.value ? 'rtl' : 'ltr'}`)
  };
}
function provideRtl(props, localeScope) {
  const currentScope = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(RtlSymbol);
  if (!currentScope) throw new Error('[Vuetify] Could not find injected rtl instance');
  const newScope = createRtlScope(currentScope, localeScope, props);
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.provide)(RtlSymbol, newScope);
  return newScope;
}
function useRtl() {
  const currentScope = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(RtlSymbol);
  if (!currentScope) throw new Error('[Vuetify] Could not find injected rtl instance');
  return currentScope;
}
;// CONCATENATED MODULE: ./src/components/VApp/VApp.tsx

// Styles
 // Composables


 // Utilities



/* harmony default export */ const VApp = (defineComponent({
  name: 'VApp',
  props: { ...makeLayoutProps({
      fullHeight: true
    }),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      layoutClasses
    } = createLayout(props);
    const {
      rtlClasses
    } = useRtl();
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": ['v-application', themeClasses.value, layoutClasses.value, rtlClasses.value],
        "data-app": "true"
      }, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": "v-application__wrap"
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)])], 2);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VApp/index.ts

;// CONCATENATED MODULE: ./src/components/VAppBar/VAppBar.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VImg/VImg.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VResponsive/VResponsive.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/composables/dimensions.ts
// Utilities

 // Types

// Composables
const makeDimensionProps = propsFactory({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, 'dimension');
function useDimension(props) {
  const dimensionStyles = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => ({
    height: convertToUnit(props.height),
    maxHeight: convertToUnit(props.maxHeight),
    maxWidth: convertToUnit(props.maxWidth),
    minHeight: convertToUnit(props.minHeight),
    minWidth: convertToUnit(props.minWidth),
    width: convertToUnit(props.width)
  }));
  return {
    dimensionStyles
  };
}
;// CONCATENATED MODULE: ./src/components/VResponsive/VResponsive.tsx

// Styles
 // Composables

 // Utilities



function useAspectStyles(props) {
  return {
    aspectStyles: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      const ratio = Number(props.aspectRatio);
      return ratio ? {
        paddingBottom: String(1 / ratio * 100) + '%'
      } : undefined;
    })
  };
}
/* harmony default export */ const VResponsive = (defineComponent({
  name: 'VResponsive',
  props: {
    aspectRatio: [String, Number],
    contentClass: String,
    ...makeDimensionProps()
  },

  setup(props, {
    slots
  }) {
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      aspectStyles
    } = useAspectStyles(props);
    return () => {
      var _slots$additional;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": "v-responsive",
        "style": dimensionStyles.value
      }, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": "v-responsive__sizer",
        "style": aspectStyles.value
      }, null, 4), (_slots$additional = slots.additional) == null ? void 0 : _slots$additional.call(slots), slots.default && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": ['v-responsive__content', props.contentClass]
      }, [slots.default()], 2)], 4);
    };
  }

}));
;// CONCATENATED MODULE: ./src/util/globals.ts
const IS_NODE = typeof process !== 'undefined';
const IN_BROWSER = typeof window !== 'undefined';
const IS_DEBUG = IS_NODE && process.env.DEBUG === 'true';
const IS_PROD = IS_NODE && "production" === 'production';
const SUPPORTS_INTERSECTION = IN_BROWSER && 'IntersectionObserver' in window;
const SUPPORTS_TOUCH = IN_BROWSER && ('ontouchstart' in window || window.navigator.maxTouchPoints > 0);
;// CONCATENATED MODULE: ./src/directives/intersect/index.ts
// Utils
 // Types

function mounted(el, binding) {
  if (!SUPPORTS_INTERSECTION) return;
  const modifiers = binding.modifiers || {};
  const value = binding.value;
  const {
    handler,
    options
  } = typeof value === 'object' ? value : {
    handler: value,
    options: {}
  };
  const observer = new IntersectionObserver((entries = [], observer) => {
    /* istanbul ignore if */
    if (!el._observe) return; // Just in case, should never fire

    const isIntersecting = entries.some(entry => entry.isIntersecting); // If is not quiet or has already been
    // initted, invoke the user callback

    if (handler && (!modifiers.quiet || el._observe.init) && (!modifiers.once || isIntersecting || !el._observe.init)) {
      handler(isIntersecting, entries, observer);
    }

    if (isIntersecting && modifiers.once) unmounted(el);else el._observe.init = true;
  }, options);
  el._observe = {
    init: false,
    observer
  };
  observer.observe(el);
}

function unmounted(el) {
  /* istanbul ignore if */
  if (!el._observe) return;

  el._observe.observer.unobserve(el);

  delete el._observe;
}

const Intersect = {
  mounted,
  unmounted
};
/* harmony default export */ const intersect = (Intersect);
;// CONCATENATED MODULE: ./src/composables/transition.ts
// Utilities

 // Types

const makeTransitionProps = propsFactory({
  transition: {
    type: [Boolean, String, Object],
    default: 'fade-transition',
    validator: val => val !== true
  }
}, 'transition');
const MaybeTransition = (props, {
  slots
}) => {
  var _slots$default;

  const {
    transition,
    ...rest
  } = props;
  if (!transition || typeof transition === 'boolean') return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
  const {
    component = external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Transition,
    ...customProps
  } = typeof transition === 'object' ? transition : {};
  return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(component, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)(typeof transition === 'string' ? {
    name: transition
  } : customProps, rest), slots);
};
;// CONCATENATED MODULE: ./src/util/useRender.ts

function useRender(render) {
  const vm = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.getCurrentInstance)();
  vm.render = render;
}
;// CONCATENATED MODULE: ./src/components/VImg/VImg.tsx

 // Components

 // Directives

 // Composables

 // Utilities


 // Types

/* harmony default export */ const VImg = (defineComponent({
  name: 'VImg',
  directives: {
    intersect: intersect
  },
  props: {
    aspectRatio: [String, Number],
    alt: String,
    cover: Boolean,
    eager: Boolean,
    lazySrc: String,
    options: {
      type: Object,
      // For more information on types, navigate to:
      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
      default: () => ({
        root: undefined,
        rootMargin: undefined,
        threshold: undefined
      })
    },
    position: {
      type: String,
      default: 'center center'
    },
    sizes: String,
    src: {
      type: [String, Object],
      default: ''
    },
    srcset: String,
    ...makeTransitionProps()
  },
  emits: ['loadstart', 'load', 'error'],

  setup(props, {
    emit,
    slots
  }) {
    const currentSrc = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(''); // Set from srcset

    const image = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
    const state = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(props.eager ? 'loading' : 'idle');
    const naturalWidth = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
    const naturalHeight = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
    const normalisedSrc = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      return props.src && typeof props.src === 'object' ? {
        src: props.src.src,
        srcset: props.srcset || props.src.srcset,
        lazySrc: props.lazySrc || props.src.lazySrc,
        aspect: Number(props.aspectRatio || props.src.aspect)
      } : {
        src: props.src,
        srcset: props.srcset,
        lazySrc: props.lazySrc,
        aspect: Number(props.aspectRatio || 0)
      };
    });
    const aspectRatio = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
    });
    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(() => props.src, () => {
      init(state.value !== 'idle');
    }); // TODO: getSrc when window width changes

    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeMount)(() => init());

    function init(isIntersecting) {
      if (props.eager && isIntersecting) return;
      if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager) return;
      state.value = 'loading';
      (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.nextTick)(() => {
        var _image$value, _image$value2;

        emit('loadstart', ((_image$value = image.value) == null ? void 0 : _image$value.currentSrc) || normalisedSrc.value.src);

        if ((_image$value2 = image.value) != null && _image$value2.complete) {
          if (!image.value.naturalWidth) {
            onError();
          }

          if (state.value === 'error') return;
          if (!aspectRatio.value) pollForSize(image.value, null);
          onLoad();
        } else {
          if (!aspectRatio.value) pollForSize(image.value);
          getSrc();
        }
      });

      if (normalisedSrc.value.lazySrc) {
        const lazyImg = new Image();
        lazyImg.src = normalisedSrc.value.lazySrc;
        pollForSize(lazyImg, null);
      }
    }

    function onLoad() {
      var _image$value3;

      getSrc();
      state.value = 'loaded';
      emit('load', ((_image$value3 = image.value) == null ? void 0 : _image$value3.currentSrc) || normalisedSrc.value.src);
    }

    function onError() {
      var _image$value4;

      state.value = 'error';
      emit('error', ((_image$value4 = image.value) == null ? void 0 : _image$value4.currentSrc) || normalisedSrc.value.src);
    }

    function getSrc() {
      const img = image.value;
      if (img) currentSrc.value = img.currentSrc || img.src;
    }

    function pollForSize(img, timeout = 100) {
      const poll = () => {
        const {
          naturalHeight: imgHeight,
          naturalWidth: imgWidth
        } = img;

        if (imgHeight || imgWidth) {
          naturalWidth.value = imgWidth;
          naturalHeight.value = imgHeight;
        } else if (!img.complete && state.value === 'loading' && timeout != null) {
          setTimeout(poll, timeout);
        } else if (img.currentSrc.endsWith('.svg') || img.currentSrc.startsWith('data:image/svg+xml')) {
          naturalWidth.value = 1;
          naturalHeight.value = 1;
        }
      };

      poll();
    }

    const containClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => ({
      'v-img__img--cover': props.cover,
      'v-img__img--contain': !props.cover
    }));

    const __image = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _slots$sources;

      if (!normalisedSrc.value.src || state.value === 'idle') return;
      const img = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)('img', {
        class: ['v-img__img', containClasses.value],
        src: normalisedSrc.value.src,
        srcset: normalisedSrc.value.srcset,
        sizes: props.sizes,
        ref: image,
        onLoad,
        onError
      });
      const sources = (_slots$sources = slots.sources) == null ? void 0 : _slots$sources.call(slots);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)(sources ? (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("picture", {
          "class": "v-img__picture"
        }, [sources, img]) : img, [[external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.vShow, state.value === 'loaded']])],
        _: 2
      }, 8, ["transition", "appear"]);
    });

    const __preloadImage = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(MaybeTransition, {
      "transition": props.transition
    }, {
      default: () => [normalisedSrc.value.lazySrc && state.value !== 'loaded' && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("img", {
        "class": ['v-img__img', 'v-img__img--preload', containClasses.value],
        "src": normalisedSrc.value.lazySrc,
        "alt": ""
      }, null, 10, ["src"])]
    }, 8, ["transition"]));

    const __placeholder = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      if (!slots.placeholder) return;
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [(state.value === 'loading' || state.value === 'error' && !slots.error) && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-img__placeholder"
        }, [slots.placeholder()])]
      }, 8, ["transition", "appear"]);
    });

    const __error = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      if (!slots.error) return;
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [state.value === 'error' && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-img__error"
        }, [slots.error()])]
      }, 8, ["transition", "appear"]);
    });

    useRender(() => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VResponsive, {
      "class": "v-img",
      "aspectRatio": aspectRatio.value,
      "aria-label": props.alt,
      "role": props.alt ? 'img' : undefined
    }, {
      additional: () => [__image.value, __preloadImage.value, __placeholder.value, __error.value],
      default: slots.default
    }, 8, ["aspectRatio", "aria-label", "role"]), [[(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDirective)("intersect"), {
      handler: init,
      options: props.options
    }, null, {
      once: true
    }]]));
    return {
      currentSrc,
      image,
      state,
      naturalWidth,
      naturalHeight
    };
  }

}));
;// CONCATENATED MODULE: ./src/composables/border.ts
// Utilities

 // Types

// Composables
const makeBorderProps = propsFactory({
  border: [Boolean, Number, String]
}, 'border');
function useBorder(props, name) {
  const borderClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const classes = [];

    if (props.border != null && props.border !== false) {
      classes.push(`${name}--border`);
    }

    if (typeof props.border === 'string' && props.border !== '' || props.border === 0) {
      for (const value of String(props.border).split(' ')) {
        classes.push(`border-${value}`);
      }
    }

    return classes;
  });
  return {
    borderClasses
  };
}
;// CONCATENATED MODULE: ./src/composables/density.ts
// Utilities

 // Types

const allowedDensities = [null, 'default', 'comfortable', 'compact'];
// Composables
const makeDensityProps = propsFactory({
  density: {
    type: String,
    default: 'default',
    validator: v => allowedDensities.includes(v)
  }
}, 'density');
function useDensity(props, name) {
  const densityClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    return `${name}--density-${props.density}`;
  });
  return {
    densityClasses
  };
}
;// CONCATENATED MODULE: ./src/composables/elevation.ts
// Utilities

 // Types

// Composables
const makeElevationProps = propsFactory({
  elevation: {
    type: [Number, String],

    validator(v) {
      const value = parseInt(v);
      return !isNaN(value) && value >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      value <= 24;
    }

  }
}, 'elevation');
function useElevation(props) {
  const elevationClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const classes = [];
    if (props.elevation == null) return classes;
    classes.push(`elevation-${props.elevation}`);
    return classes;
  });
  return {
    elevationClasses
  };
}
;// CONCATENATED MODULE: ./src/composables/rounded.ts
// Utilities

 // Types

// Composables
const makeRoundedProps = propsFactory({
  rounded: {
    type: [Boolean, Number, String],
    default: undefined
  },
  tile: Boolean
}, 'rounded');
function useRounded(props, name) {
  const roundedClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const classes = [];

    if (props.tile) {
      classes.push(`${name}--tile`);
    } else if (props.rounded === true || props.rounded === '') {
      classes.push(`${name}--rounded`);
    } else if (typeof props.rounded === 'string' || props.rounded === 0) {
      for (const value of String(props.rounded).split(' ')) {
        classes.push(`rounded-${value}`);
      }
    }

    return classes;
  });
  return {
    roundedClasses
  };
}
;// CONCATENATED MODULE: ./src/composables/tag.ts
// Utilities
 // Types

// Composables
const makeTagProps = propsFactory({
  tag: {
    type: String,
    default: 'div'
  }
}, 'tag');
;// CONCATENATED MODULE: ./src/composables/color.ts
// Utilities

 // Types

// Composables
function useColor(colors) {
  const backgroundIsCssColor = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => isCssColor(colors.value.background));
  const textIsCssColor = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => isCssColor(colors.value.text));
  const colorClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const classes = [];

    if (colors.value.background && !backgroundIsCssColor.value) {
      classes.push(`bg-${colors.value.background}`);
    }

    if (colors.value.text && !textIsCssColor.value) {
      classes.push(`text-${colors.value.text}`);
    }

    return classes;
  });
  const colorStyles = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const styles = {};

    if (colors.value.background && backgroundIsCssColor.value) {
      styles.backgroundColor = colors.value.background;
    }

    if (colors.value.text && textIsCssColor.value) {
      styles.color = colors.value.text;
      styles.caretColor = colors.value.text;
    }

    return styles;
  });
  return {
    colorClasses,
    colorStyles
  };
}
function useTextColor(props, name) {
  const colors = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => ({
    text: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.isRef)(props) ? props.value : name ? props[name] : null
  }));
  const {
    colorClasses: textColorClasses,
    colorStyles: textColorStyles
  } = useColor(colors);
  return {
    textColorClasses,
    textColorStyles
  };
}
function useBackgroundColor(props, name) {
  const colors = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => ({
    background: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.isRef)(props) ? props.value : name ? props[name] : null
  }));
  const {
    colorClasses: backgroundColorClasses,
    colorStyles: backgroundColorStyles
  } = useColor(colors);
  return {
    backgroundColorClasses,
    backgroundColorStyles
  };
}
;// CONCATENATED MODULE: ./src/composables/proxiedModel.ts
// Utilities

 // Types

// Composables
function useProxiedModel(props, prop, defaultValue, transformIn = v => v, transformOut = v => v) {
  const vm = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.getCurrentInstance)();
  if (!vm) consoleError('useProxiedModel must be called from inside a setup function');
  const propIsDefined = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    var _vm$vnode$props, _vm$vnode$props2;

    return !!(typeof props[prop] !== 'undefined' && (vm != null && (_vm$vnode$props = vm.vnode.props) != null && _vm$vnode$props.hasOwnProperty(prop) || vm != null && (_vm$vnode$props2 = vm.vnode.props) != null && _vm$vnode$props2.hasOwnProperty(toKebabCase(prop))));
  });
  const internal = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(transformIn(props[prop]));
  return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)({
    get() {
      if (propIsDefined.value) return transformIn(props[prop]);else return internal.value;
    },

    set(newValue) {
      internal.value = newValue;
      vm == null ? void 0 : vm.emit(`update:${prop}`, transformOut(newValue));
    }

  });
}
;// CONCATENATED MODULE: ./src/components/VAppBar/VAppBar.tsx

// Styles
 // Components

 // Composables








 // Utilities


 // Types

/* harmony default export */ const VAppBar = (defineComponent({
  name: 'VAppBar',
  props: {
    // TODO: Implement scrolling techniques
    // hideOnScroll: Boolean
    // invertedScroll: Boolean
    // collapseOnScroll: Boolean
    // elevateOnScroll: Boolean
    // shrinkOnScroll: Boolean
    // fadeImageOnScroll: Boolean
    collapse: Boolean,
    color: String,
    flat: Boolean,
    height: {
      type: [Number, String],
      default: 64
    },
    extensionHeight: {
      type: [Number, String],
      default: 48
    },
    floating: Boolean,
    image: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    prominent: Boolean,
    prominentHeight: {
      type: [Number, String],
      default: 128
    },
    position: {
      type: String,
      default: 'top',
      validator: value => ['top', 'bottom'].includes(value)
    },
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeLayoutItemProps({
      name: 'app-bar'
    }),
    ...makeTagProps({
      tag: 'header'
    })
  },
  emits: {
    'update:modelValue': value => true
  },

  setup(props, {
    slots
  }) {
    const {
      borderClasses
    } = useBorder(props, 'v-app-bar');
    const {
      densityClasses
    } = useDensity(props, 'v-app-bar');
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, 'v-app-bar');
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    const extension = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(!!slots.extension);
    const height = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => Number(props.prominent ? props.prominentHeight : props.height) + Number(extension.value ? props.extensionHeight : 0) - (props.density === 'comfortable' ? 8 : 0) - (props.density === 'compact' ? 16 : 0));
    const isActive = useProxiedModel(props, 'modelValue', props.modelValue);
    const layoutStyles = useLayoutItem(props.name, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'priority'), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'position'), height, height, isActive);
    return () => {
      var _slots$img, _slots$default, _slots$extension;

      const hasImage = !!(slots.image || props.image);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-app-bar', {
          'v-app-bar--bottom': props.position === 'bottom',
          'v-app-bar--collapsed': props.collapse,
          'v-app-bar--flat': props.flat,
          'v-app-bar--floating': props.floating,
          'v-app-bar--is-active': isActive.value,
          'v-app-bar--prominent': props.prominent,
          'v-app-bar--absolute': props.absolute
        }, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, layoutStyles.value]
      }, {
        default: () => [hasImage && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-app-bar__image"
        }, [slots.image ? (_slots$img = slots.img) == null ? void 0 : _slots$img.call(slots, {
          src: props.image
        }) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VImg, {
          "src": props.image,
          "cover": true
        }, null, 8, ["src", "cover"])]), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-app-bar__content"
        }, [slots.prepend && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-app-bar__prepend"
        }, [slots.prepend()]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), slots.append && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-app-bar__append"
        }, [slots.append()])]), slots.extension && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-app-bar__extension",
          "style": {
            height: convertToUnit(props.extensionHeight)
          },
          "ref": extension
        }, [(_slots$extension = slots.extension) == null ? void 0 : _slots$extension.call(slots)], 4)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VBtn/VBtn.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VIcon/VIcon.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/composables/size.ts
// Utilities

 // Types

const predefinedSizes = ['x-small', 'small', 'default', 'large', 'x-large'];
// Composables
const makeSizeProps = propsFactory({
  size: {
    type: [String, Number],
    default: 'default'
  }
}, 'size');
function useSize(props, name) {
  const sizeClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    return predefinedSizes.includes(props.size) ? `${name}--size-${props.size}` : null;
  });
  const sizeStyles = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    return !predefinedSizes.includes(props.size) && props.size ? {
      width: convertToUnit(props.size),
      height: convertToUnit(props.size)
    } : null;
  });
  return {
    sizeClasses,
    sizeStyles
  };
}
;// CONCATENATED MODULE: ./src/composables/icons.tsx

// Utilities

 // Types

const IconSymbol = Symbol.for('vuetify:icons');
const makeIconProps = propsFactory({
  icon: {
    type: [String, Object],
    required: true
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: true
  }
}, 'icon');
const VComponentIcon = defineComponent({
  name: 'VComponentIcon',
  props: makeIconProps(),

  setup(props) {
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, null, {
        default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.icon, null, null)]
      });
    };
  }

});
const VSvgIcon = defineComponent({
  name: 'VSvgIcon',
  inheritAttrs: false,
  props: makeIconProps(),

  setup(props, {
    attrs
  }) {
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)(attrs, {
        "style": null
      }), {
        default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("svg", {
          "class": "v-icon__svg",
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": "0 0 24 24",
          "role": "img",
          "aria-hidden": "true"
        }, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("path", {
          "d": props.icon
        }, null, 8, ["d"])])]
      }, 16);
    };
  }

});
const VLigatureIcon = defineComponent({
  name: 'VLigatureIcon',
  props: makeIconProps(),

  setup(props) {
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, null, {
        default: () => [props.icon]
      });
    };
  }

});
const VClassIcon = defineComponent({
  name: 'VClassIcon',
  props: makeIconProps(),

  setup(props) {
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": props.icon
      }, null, 8, ["class"]);
    };
  }

});
const defaultSets = {
  svg: {
    component: VSvgIcon
  },
  class: {
    component: VClassIcon
  }
}; // Composables

const useIcon = props => {
  const icons = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(IconSymbol);
  if (!icons) throw new Error('Missing Vuetify Icons provide!');
  const iconData = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const iconAlias = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.isRef)(props) ? props.value : props.icon;
    if (!iconAlias) throw new Error('Icon value is undefined or null');
    let icon = iconAlias;

    if (typeof iconAlias === 'string' && iconAlias.includes('$')) {
      var _icons$aliases;

      icon = (_icons$aliases = icons.aliases) == null ? void 0 : _icons$aliases[iconAlias.slice(iconAlias.indexOf('$') + 1)];
    }

    if (!icon) throw new Error(`Could not find aliased icon "${iconAlias}"`);

    if (typeof icon !== 'string') {
      return {
        component: VComponentIcon,
        icon
      };
    }

    const hasSet = icon.includes(':');
    const setName = hasSet ? icon.split(':')[0] : icons.defaultSet;
    const iconName = hasSet ? icon.split(':')[1] : icon;
    const set = icons.sets[setName != null ? setName : icons.defaultSet];

    if (!set) {
      throw new Error(`Could not find icon set "${setName}"`);
    }

    return {
      component: set.component,
      icon: iconName
    };
  });
  return {
    iconData
  };
};
;// CONCATENATED MODULE: ./src/components/VIcon/VIcon.tsx

// Styles
 // Composables




 // Utilities


 // Types

/* harmony default export */ const VIcon = (defineComponent({
  name: 'VIcon',
  props: {
    color: String,
    left: Boolean,
    right: Boolean,
    icon: {
      type: [String, Object]
    },
    ...makeSizeProps(),
    ...makeTagProps({
      tag: 'i'
    })
  },

  setup(props, {
    slots
  }) {
    let slotIcon;

    if (slots.default) {
      slotIcon = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
        var _slots$default, _flattenFragments$fil;

        const slot = (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
        if (!slot) return;
        return (_flattenFragments$fil = flattenFragments(slot).filter(node => node.children && typeof node.children === 'string')[0]) == null ? void 0 : _flattenFragments$fil.children;
      });
    }

    const {
      iconData
    } = useIcon(slotIcon || props);
    const {
      sizeClasses
    } = useSize(props, 'v-icon');
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(iconData.value.component, {
        "tag": props.tag,
        "icon": iconData.value.icon,
        "class": ['v-icon', 'notranslate', sizeClasses.value, textColorClasses.value, {
          'v-icon--left': props.left,
          'v-icon--right': props.right
        }],
        "style": [!sizeClasses.value ? {
          fontSize: convertToUnit(props.size),
          width: convertToUnit(props.size),
          height: convertToUnit(props.size)
        } : undefined, textColorStyles.value],
        "aria-hidden": "true"
      }, null, 8, ["tag", "icon", "class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/composables/position.ts
// Utilities

 // Types

const positionValues = ['static', 'relative', 'fixed', 'absolute', 'sticky'];
// Composables
const makePositionProps = propsFactory({
  absolute: Boolean,
  bottom: [Boolean, Number, String],
  fixed: Boolean,
  left: [Boolean, Number, String],
  position: {
    type: String,
    validator:
    /* istanbul ignore next */
    v => positionValues.includes(v)
  },
  right: [Boolean, Number, String],
  top: [Boolean, Number, String]
}, 'position');
function usePosition(props, name) {
  const targets = ['top', 'right', 'bottom', 'left'];
  const positionClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    if (props.fixed) return `${name}--fixed`;
    if (props.absolute) return `${name}--absolute`;
    return props.position ? `position-${props.position}` : undefined;
  });
  const positionStyles = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const styles = {};

    for (const target of targets) {
      const prop = props[target];
      if (prop == null || prop === false) continue;
      styles[target] = convertToUnit(prop === true ? '0' : String(prop));
    }

    return styles;
  });
  return {
    positionClasses,
    positionStyles
  };
}
;// CONCATENATED MODULE: ./src/composables/router.tsx
// Utilities

 // Types

function useRoute() {
  const vm = getCurrentInstance();
  return computed(() => {
    var _vm$proxy;

    return vm == null ? void 0 : (_vm$proxy = vm.proxy) == null ? void 0 : _vm$proxy.$route;
  });
}
function useRouter() {
  var _getCurrentInstance, _getCurrentInstance$p;

  return (_getCurrentInstance = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.getCurrentInstance)()) == null ? void 0 : (_getCurrentInstance$p = _getCurrentInstance.proxy) == null ? void 0 : _getCurrentInstance$p.$router;
}
function useLink(props, attrs) {
  const RouterLink = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDynamicComponent)('RouterLink');
  const isLink = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => !!(props.href || props.to));
  const isClickable = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    return (isLink == null ? void 0 : isLink.value) || !!(attrs.onClick || attrs.onClickOnce);
  });

  if (typeof RouterLink === 'string') {
    return {
      isLink,
      isClickable,
      href: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'href')
    };
  }

  const link = props.to ? RouterLink.useLink(props) : undefined;
  return { ...link,
    isLink,
    isClickable,
    href: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => props.to ? link == null ? void 0 : link.route.value.href : props.href)
  };
}
const makeRouterProps = propsFactory({
  href: String,
  replace: Boolean,
  to: [String, Object]
}, 'router');
function useBackButton(cb) {
  const router = useRouter();
  let popped = false;
  let removeGuard;
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onMounted)(() => {
    window.addEventListener('popstate', onPopstate);
    removeGuard = router == null ? void 0 : router.beforeEach((to, from, next) => {
      setTimeout(() => popped ? cb(next) : next());
    });
  });
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeUnmount)(() => {
    var _removeGuard;

    window.removeEventListener('popstate', onPopstate);
    (_removeGuard = removeGuard) == null ? void 0 : _removeGuard();
  });

  function onPopstate(e) {
    if (e.state.replaced) return;
    popped = true;
    setTimeout(() => popped = false);
  }
}
;// CONCATENATED MODULE: ./src/composables/variant.tsx

// Composables
 // Utilities


 // Types

const allowedVariants = ['contained', 'outlined', 'plain', 'text', 'contained-text'];
function genOverlays(isClickable, name) {
  return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Fragment, null, [isClickable && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
    "class": `${name}__overlay`
  }, null), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
    "class": `${name}__underlay`
  }, null)]);
}
const makeVariantProps = propsFactory({
  color: String,
  textColor: String,
  variant: {
    type: String,
    default: 'contained',
    validator: v => allowedVariants.includes(v)
  }
}, 'variant');
function useVariant(props, name) {
  const variantClasses = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    return `${name}--variant-${props.variant}`;
  });
  const {
    colorClasses,
    colorStyles
  } = useColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => ({
    text: props.textColor,
    [props.variant === 'contained' ? 'background' : 'text']: props.color
  })));
  return {
    colorClasses,
    colorStyles,
    variantClasses
  };
}
;// CONCATENATED MODULE: ./src/directives/ripple/VRipple.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/directives/ripple/index.ts
// Styles
 // Utilities

 // Types

const rippleStop = Symbol('rippleStop');
const DELAY_RIPPLE = 80;

function transform(el, value) {
  el.style.transform = value;
  el.style.webkitTransform = value;
}

function opacity(el, value) {
  el.style.opacity = `calc(${value} * var(--v-theme-overlay-multiplier))`;
}

function isTouchEvent(e) {
  return e.constructor.name === 'TouchEvent';
}

function isKeyboardEvent(e) {
  return e.constructor.name === 'KeyboardEvent';
}

const calculate = (e, el, value = {}) => {
  var _el$_ripple;

  let localX = 0;
  let localY = 0;

  if (!isKeyboardEvent(e)) {
    const offset = el.getBoundingClientRect();
    const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
    localX = target.clientX - offset.left;
    localY = target.clientY - offset.top;
  }

  let radius = 0;
  let scale = 0.3;

  if ((_el$_ripple = el._ripple) != null && _el$_ripple.circle) {
    scale = 0.15;
    radius = el.clientWidth / 2;
    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
  } else {
    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
  }

  const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
  const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
  const x = value.center ? centerX : `${localX - radius}px`;
  const y = value.center ? centerY : `${localY - radius}px`;
  return {
    radius,
    scale,
    x,
    y,
    centerX,
    centerY
  };
};

const ripples = {
  /* eslint-disable max-statements */
  show(e, el, value = {}) {
    var _el$_ripple2;

    if (!(el != null && (_el$_ripple2 = el._ripple) != null && _el$_ripple2.enabled)) {
      return;
    }

    const container = document.createElement('span');
    const animation = document.createElement('span');
    container.appendChild(animation);
    container.className = 'v-ripple__container';

    if (value.class) {
      container.className += ` ${value.class}`;
    }

    const {
      radius,
      scale,
      x,
      y,
      centerX,
      centerY
    } = calculate(e, el, value);
    const size = `${radius * 2}px`;
    animation.className = 'v-ripple__animation';
    animation.style.width = size;
    animation.style.height = size;
    el.appendChild(container);
    const computed = window.getComputedStyle(el);

    if (computed && computed.position === 'static') {
      el.style.position = 'relative';
      el.dataset.previousPosition = 'static';
    }

    animation.classList.add('v-ripple__animation--enter');
    animation.classList.add('v-ripple__animation--visible');
    transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);
    opacity(animation, 0);
    animation.dataset.activated = String(performance.now());
    setTimeout(() => {
      animation.classList.remove('v-ripple__animation--enter');
      animation.classList.add('v-ripple__animation--in');
      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
      opacity(animation, 0.08);
    }, 0);
  },

  hide(el) {
    var _el$_ripple3;

    if (!(el != null && (_el$_ripple3 = el._ripple) != null && _el$_ripple3.enabled)) return;
    const ripples = el.getElementsByClassName('v-ripple__animation');
    if (ripples.length === 0) return;
    const animation = ripples[ripples.length - 1];
    if (animation.dataset.isHiding) return;else animation.dataset.isHiding = 'true';
    const diff = performance.now() - Number(animation.dataset.activated);
    const delay = Math.max(250 - diff, 0);
    setTimeout(() => {
      animation.classList.remove('v-ripple__animation--in');
      animation.classList.add('v-ripple__animation--out');
      opacity(animation, 0);
      setTimeout(() => {
        const ripples = el.getElementsByClassName('v-ripple__animation');

        if (ripples.length === 1 && el.dataset.previousPosition) {
          el.style.position = el.dataset.previousPosition;
          delete el.dataset.previousPosition;
        }

        animation.parentNode && el.removeChild(animation.parentNode);
      }, 300);
    }, delay);
  }

};

function isRippleEnabled(value) {
  return typeof value === 'undefined' || !!value;
}

function rippleShow(e) {
  const value = {};
  const element = e.currentTarget;
  if (!(element != null && element._ripple) || element._ripple.touched || e[rippleStop]) return; // Don't allow the event to trigger ripples on any other elements

  e[rippleStop] = true;

  if (isTouchEvent(e)) {
    element._ripple.touched = true;
    element._ripple.isTouch = true;
  } else {
    // It's possible for touch events to fire
    // as mouse events on Android/iOS, this
    // will skip the event call if it has
    // already been registered as touch
    if (element._ripple.isTouch) return;
  }

  value.center = element._ripple.centered || isKeyboardEvent(e);

  if (element._ripple.class) {
    value.class = element._ripple.class;
  }

  if (isTouchEvent(e)) {
    // already queued that shows or hides the ripple
    if (element._ripple.showTimerCommit) return;

    element._ripple.showTimerCommit = () => {
      ripples.show(e, element, value);
    };

    element._ripple.showTimer = window.setTimeout(() => {
      var _element$_ripple;

      if (element != null && (_element$_ripple = element._ripple) != null && _element$_ripple.showTimerCommit) {
        element._ripple.showTimerCommit();

        element._ripple.showTimerCommit = null;
      }
    }, DELAY_RIPPLE);
  } else {
    ripples.show(e, element, value);
  }
}

function rippleHide(e) {
  const element = e.currentTarget;
  if (!element || !element._ripple) return;
  window.clearTimeout(element._ripple.showTimer); // The touch interaction occurs before the show timer is triggered.
  // We still want to show ripple effect.

  if (e.type === 'touchend' && element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit();

    element._ripple.showTimerCommit = null; // re-queue ripple hiding

    element._ripple.showTimer = setTimeout(() => {
      rippleHide(e);
    });
    return;
  }

  window.setTimeout(() => {
    if (element._ripple) {
      element._ripple.touched = false;
    }
  });
  ripples.hide(element);
}

function rippleCancelShow(e) {
  const element = e.currentTarget;
  if (!element || !element._ripple) return;

  if (element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit = null;
  }

  window.clearTimeout(element._ripple.showTimer);
}

let keyboardRipple = false;

function keyboardRippleShow(e) {
  if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
    keyboardRipple = true;
    rippleShow(e);
  }
}

function keyboardRippleHide(e) {
  keyboardRipple = false;
  rippleHide(e);
}

function focusRippleHide(e) {
  if (keyboardRipple) {
    keyboardRipple = false;
    rippleHide(e);
  }
}

function updateRipple(el, binding, wasEnabled) {
  var _el$_ripple4;

  const {
    value,
    modifiers
  } = binding;
  const enabled = isRippleEnabled(value);

  if (!enabled) {
    ripples.hide(el);
  }

  el._ripple = (_el$_ripple4 = el._ripple) != null ? _el$_ripple4 : {};
  el._ripple.enabled = enabled;
  el._ripple.centered = modifiers.center;
  el._ripple.circle = modifiers.circle;

  if (isObject(value) && value.class) {
    el._ripple.class = value.class;
  }

  if (enabled && !wasEnabled) {
    el.addEventListener('touchstart', rippleShow, {
      passive: true
    });
    el.addEventListener('touchend', rippleHide, {
      passive: true
    });
    el.addEventListener('touchmove', rippleCancelShow, {
      passive: true
    });
    el.addEventListener('touchcancel', rippleHide);
    el.addEventListener('mousedown', rippleShow);
    el.addEventListener('mouseup', rippleHide);
    el.addEventListener('mouseleave', rippleHide);
    el.addEventListener('keydown', keyboardRippleShow);
    el.addEventListener('keyup', keyboardRippleHide);
    el.addEventListener('blur', focusRippleHide); // Anchor tags can be dragged, causes other hides to fail - #1537

    el.addEventListener('dragstart', rippleHide, {
      passive: true
    });
  } else if (!enabled && wasEnabled) {
    removeListeners(el);
  }
}

function removeListeners(el) {
  el.removeEventListener('mousedown', rippleShow);
  el.removeEventListener('touchstart', rippleShow);
  el.removeEventListener('touchend', rippleHide);
  el.removeEventListener('touchmove', rippleCancelShow);
  el.removeEventListener('touchcancel', rippleHide);
  el.removeEventListener('mouseup', rippleHide);
  el.removeEventListener('mouseleave', rippleHide);
  el.removeEventListener('keydown', keyboardRippleShow);
  el.removeEventListener('keyup', keyboardRippleHide);
  el.removeEventListener('dragstart', rippleHide);
  el.removeEventListener('blur', focusRippleHide);
}

function ripple_mounted(el, binding) {
  updateRipple(el, binding, false);
}

function ripple_unmounted(el) {
  delete el._ripple;
  removeListeners(el);
}

function updated(el, binding) {
  if (binding.value === binding.oldValue) {
    return;
  }

  const wasEnabled = isRippleEnabled(binding.oldValue);
  updateRipple(el, binding, wasEnabled);
}

const Ripple = {
  mounted: ripple_mounted,
  unmounted: ripple_unmounted,
  updated
};
/* harmony default export */ const ripple = ((/* unused pure expression or super */ null && (Ripple)));
;// CONCATENATED MODULE: ./src/components/VBtn/VBtn.tsx

// Styles
 // Components

 // Composables











 // Directives

 // Utilities



/* harmony default export */ const VBtn = (defineComponent({
  name: 'VBtn',
  directives: {
    Ripple: Ripple
  },
  props: {
    flat: Boolean,
    icon: [Boolean, String],
    prependIcon: String,
    appendIcon: String,
    block: Boolean,
    stacked: Boolean,
    disabled: Boolean,
    ripple: {
      type: Boolean,
      default: true
    },
    ...makeBorderProps(),
    ...makeRoundedProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRouterProps(),
    ...makeSizeProps(),
    ...makeTagProps({
      tag: 'button'
    }),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: 'contained'
    })
  },

  setup(props, {
    attrs,
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-btn');
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props, 'v-btn');
    const {
      densityClasses
    } = useDensity(props, 'v-btn');
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, 'v-btn');
    const {
      roundedClasses
    } = useRounded(props, 'v-btn');
    const {
      sizeClasses
    } = useSize(props, 'v-btn');
    const link = useLink(props, attrs);
    const isElevated = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      return props.variant === 'contained' && !(props.disabled || props.flat || props.border);
    });
    return () => {
      var _link$isExactActive, _slots$default;

      const Tag = link.isLink.value ? 'a' : props.tag;
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(Tag, {
        "type": Tag === 'a' ? undefined : 'button',
        "class": ['v-btn', {
          'v-btn--active': (_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value,
          'v-btn--block': props.block,
          'v-btn--disabled': props.disabled,
          'v-btn--elevated': isElevated.value,
          'v-btn--icon': !!props.icon,
          'v-btn--stacked': props.stacked
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value, positionStyles.value],
        "disabled": props.disabled || undefined,
        "href": link.href.value,
        "onClick": props.disabled || link.navigate
      }, {
        default: () => [genOverlays(true, 'v-btn'), !props.icon && props.prependIcon && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VIcon, {
          "class": "v-btn__icon",
          "icon": props.prependIcon,
          "left": !props.stacked
        }, null, 8, ["icon", "left"]), typeof props.icon === 'boolean' ? (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VIcon, {
          "class": "v-btn__icon",
          "icon": props.icon,
          "size": props.size
        }, null, 8, ["icon", "size"]), !props.icon && props.appendIcon && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VIcon, {
          "class": "v-btn__icon",
          "icon": props.appendIcon,
          "right": !props.stacked
        }, null, 8, ["icon", "right"])],
        _: 1
      }, 8, ["type", "class", "style", "disabled", "href", "onClick"]), [[(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDirective)("ripple"), !props.disabled && props.ripple, null]]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VAppBar/VAppBarNavIcon.tsx

// Components
 // Utilities


/* harmony default export */ const VAppBarNavIcon = (defineComponent({
  name: 'VAppBarNavIcon',
  props: {
    icon: {
      type: String,
      default: '$menu'
    }
  },

  setup(props, {
    slots
  }) {
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBtn, {
        "class": "v-app-bar-nav-icon",
        "icon": props.icon
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
      }, 8, ["icon"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VAppBar/VAppBarTitle.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VAppBar/VAppBarTitle.tsx

// Styles
 // Composables

 // Utilities


/* harmony default export */ const VAppBarTitle = (defineComponent({
  name: 'VAppBarTitle',
  props: { ...makeTagProps({
      tag: 'header'
    })
  },

  setup(props, {
    slots
  }) {
    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
      "class": "v-app-bar-title"
    }, {
      default: () => [slots.default && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": "v-app-bar-title__placeholder"
      }, [slots.default()])]
    });
  }

}));
;// CONCATENATED MODULE: ./src/components/VAppBar/index.ts



;// CONCATENATED MODULE: ./src/components/VAlert/VAlert.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VAvatar/VAvatar.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VAvatar/VAvatar.tsx

// Styles
 // Components


 // Composables





 // Utilities



/* harmony default export */ const VAvatar = (defineComponent({
  name: 'VAvatar',
  props: {
    color: String,
    left: Boolean,
    right: Boolean,
    icon: String,
    image: String,
    ...makeDensityProps(),
    ...makeRoundedProps(),
    ...makeSizeProps(),
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    const {
      densityClasses
    } = useDensity(props, 'v-avatar');
    const {
      roundedClasses
    } = useRounded(props, 'v-avatar');
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props, 'v-avatar');
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-avatar', {
          'v-avatar--left': props.left,
          'v-avatar--right': props.right
        }, backgroundColorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value],
        "style": [backgroundColorStyles.value, sizeStyles.value]
      }, {
        default: () => [props.image && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VImg, {
          "src": props.image,
          "alt": ""
        }, null, 8, ["src"]), props.icon && !props.image && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VIcon, {
          "icon": props.icon
        }, null, 8, ["icon"]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VAlert/VAlert.tsx

// Styles
 // Components


 // Composables










 // Utilities


 // Types

const allowedTypes = ['success', 'info', 'warning', 'error'];
/* harmony default export */ const VAlert = (defineComponent({
  name: 'VAlert',
  props: {
    border: {
      type: [Boolean, String],
      validator: val => {
        return typeof val === 'boolean' || ['top', 'end', 'bottom', 'start'].includes(val);
      }
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
      type: String,
      default: '$close'
    },
    closeLabel: {
      type: String,
      default: '$vuetify.close'
    },
    icon: {
      type: [Boolean, String],
      default: null
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    prominent: Boolean,
    sticky: Boolean,
    text: String,
    tip: Boolean,
    type: {
      type: String,
      validator: val => allowedTypes.includes(val)
    },
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps()
  },
  emits: {
    'update:modelValue': value => true
  },

  setup(props, {
    slots
  }) {
    const borderProps = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => ({
      border: props.border === true || props.tip ? 'start' : props.border
    }));
    const isActive = useProxiedModel(props, 'modelValue');
    const icon = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _props$icon;

      if (props.icon === false) return undefined;
      if (!props.type) return props.icon;
      return (_props$icon = props.icon) != null ? _props$icon : `$${props.type}`;
    });
    const variantProps = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.reactive)({
      color: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
        var _props$color;

        return (_props$color = props.color) != null ? _props$color : props.type;
      }),
      textColor: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'textColor'),
      variant: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'variant')
    });
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(borderProps.value, 'v-alert');
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps, 'v-alert');
    const {
      densityClasses
    } = useDensity(props, 'v-alert');
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, 'v-alert');
    const {
      roundedClasses
    } = useRounded(props, 'v-alert');
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _props$borderColor;

      return (_props$borderColor = props.borderColor) != null ? _props$borderColor : props.tip ? variantProps.color : undefined;
    }));

    function onCloseClick(e) {
      isActive.value = false;
    }

    return () => {
      const hasBorder = !!borderProps.value.border;
      const hasClose = !!(slots.close || props.closable);
      const hasPrepend = !!(slots.prepend || props.icon || props.type);
      const hasText = !!(slots.default || props.text || hasClose);
      return isActive.value && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-alert', {
          [`v-alert--border-${borderProps.value.border}`]: hasBorder,
          'v-alert--prominent': props.prominent,
          'v-alert--tip': props.tip
        }, themeClasses.value, borderClasses.value, !props.tip && colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value],
        "style": [!props.tip && colorStyles.value, positionStyles.value],
        "role": "alert"
      }, {
        default: () => [hasBorder && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": ['v-alert__border', textColorClasses.value],
          "style": textColorStyles.value
        }, null, 6), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-alert__underlay"
        }, null), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-alert__content"
        }, [hasPrepend && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-alert__avatar"
        }, [slots.prepend ? slots.prepend() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VAvatar, {
          "class": props.tip && textColorClasses.value,
          "style": props.tip && textColorStyles.value,
          "density": props.density,
          "icon": icon.value
        }, null, 8, ["class", "style", "density", "icon"])]), hasText && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-alert__text"
        }, [slots.default ? slots.default() : props.text, hasClose && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-alert__close"
        }, [slots.close ? slots.close({
          props: {
            onClick: onCloseClick
          }
        }) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBtn, {
          "density": props.density,
          "icon": props.closeIcon,
          "variant": "text",
          "onClick": onCloseClick
        }, null, 8, ["density", "icon", "onClick"])])])])],
        _: 1
      }, 8, ["class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VAlert/index.ts

;// CONCATENATED MODULE: ./src/components/VAvatar/index.ts

;// CONCATENATED MODULE: ./src/components/VBadge/VBadge.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VBadge/VBadge.tsx

// Styles
 // Components

 // Composables




 // Utilities



/* harmony default export */ const VBadge = (defineComponent({
  name: 'VBadge',
  inheritAttrs: false,
  props: {
    bordered: Boolean,
    color: {
      type: String,
      default: 'primary'
    },
    content: String,
    dot: Boolean,
    floating: Boolean,
    icon: String,
    inline: Boolean,
    label: {
      type: String,
      default: '$vuetify.badge'
    },
    location: {
      type: String,
      default: 'top-right',
      validator: value => {
        const [vertical, horizontal] = (value != null ? value : '').split('-');
        return ['top', 'bottom'].includes(vertical) && ['left', 'right'].includes(horizontal);
      }
    },
    max: [Number, String],
    modelValue: {
      type: Boolean,
      default: true
    },
    offsetX: [Number, String],
    offsetY: [Number, String],
    textColor: String,
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeTransitionProps({
      transition: 'scale-rotate-transition'
    })
  },

  setup(props, ctx) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    const {
      roundedClasses
    } = useRounded(props, 'v-badge');
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'textColor'));
    const position = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      return props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
    });

    function calculatePosition(offset) {
      return `calc(100% - ${convertToUnit(position.value + parseInt(offset != null ? offset : 0, 10))})`;
    }

    const locationStyles = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _props$location;

      const [vertical, horizontal] = ((_props$location = props.location) != null ? _props$location : '').split('-'); // TODO: RTL support

      const styles = {
        bottom: 'auto',
        left: 'auto',
        right: 'auto',
        top: 'auto'
      };

      if (!props.inline) {
        styles[horizontal === 'left' ? 'right' : 'left'] = calculatePosition(props.offsetX);
        styles[vertical === 'top' ? 'bottom' : 'top'] = calculatePosition(props.offsetY);
      }

      return styles;
    });
    return () => {
      var _ctx$slots$default, _ctx$slots, _ctx$slots$badge, _ctx$slots2;

      const value = Number(props.content);
      const content = !props.max || isNaN(value) ? props.content : value <= props.max ? value : `${props.max}+`;
      const [badgeAttrs, attrs] = extract(ctx.attrs, ['aria-atomic', 'aria-label', 'aria-live', 'role', 'title']);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)({
        "class": ['v-badge', {
          'v-badge--bordered': props.bordered,
          'v-badge--dot': props.dot,
          'v-badge--floating': props.floating,
          'v-badge--inline': props.inline
        }]
      }, attrs), {
        default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-badge__wrapper"
        }, [(_ctx$slots$default = (_ctx$slots = ctx.slots).default) == null ? void 0 : _ctx$slots$default.call(_ctx$slots), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("span", (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)({
            "class": ['v-badge__badge', backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
            "style": [backgroundColorStyles.value, locationStyles.value, textColorStyles.value],
            "aria-atomic": "true",
            "aria-label": "locale string here",
            "aria-live": "polite",
            "role": "status"
          }, badgeAttrs), [props.dot ? undefined : ctx.slots.badge ? (_ctx$slots$badge = (_ctx$slots2 = ctx.slots).badge) == null ? void 0 : _ctx$slots$badge.call(_ctx$slots2) : props.icon ? (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VIcon, {
            "icon": props.icon
          }, null, 8, ["icon"]) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("span", {
            "class": "v-badge__content"
          }, [content])], 16), [[external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.vShow, props.modelValue]])]
        }, 8, ["transition"])])]
      }, 16, ["class"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VBadge/index.ts

;// CONCATENATED MODULE: ./src/components/VBanner/VBanner.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/util/createSimpleFunctional.ts


function createSimpleFunctional(klass, tag = 'div', name) {
  return defineComponent({
    name: name != null ? name : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.capitalize)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.camelize)(klass.replace(/__/g, '-'))),
    props: {
      tag: {
        type: String,
        default: tag
      }
    },

    setup(props, {
      slots
    }) {
      return () => {
        var _slots$default;

        return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(props.tag, {
          class: klass
        }, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots));
      };
    }

  });
}
;// CONCATENATED MODULE: ./src/components/VBanner/VBannerActions.ts

/* harmony default export */ const VBannerActions = (createSimpleFunctional('v-banner-actions'));
;// CONCATENATED MODULE: ./src/components/VBanner/VBannerAvatar.tsx

// Composables
 // Utilities


/* harmony default export */ const VBannerAvatar = (defineComponent({
  name: 'VBannerAvatar',
  props: {
    left: Boolean,
    right: Boolean,
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-banner-avatar', {
          'v-banner-avatar--start': props.left,
          'v-banner-avatar--end': props.right
        }]
      }, slots, 8, ["class"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VBanner/VBannerContent.ts

/* harmony default export */ const VBannerContent = (createSimpleFunctional('v-banner-content'));
;// CONCATENATED MODULE: ./src/components/VBanner/VBannerText.ts

/* harmony default export */ const VBannerText = (createSimpleFunctional('v-banner-text'));
;// CONCATENATED MODULE: ./src/composables/display.ts
// Utilities

 // Globals

 // Types

const DisplaySymbol = Symbol.for('vuetify:display');
const defaultDisplayOptions = {
  mobileBreakpoint: 'lg',
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
};

const parseDisplayOptions = (options = defaultDisplayOptions) => {
  return mergeDeep(defaultDisplayOptions, options);
}; // Cross-browser support as described in:
// https://stackoverflow.com/questions/1248081


function getClientWidth() {
  return IN_BROWSER ? Math.max(document.documentElement.clientWidth, window.innerWidth) : 0; // SSR
}

function getClientHeight() {
  return IN_BROWSER ? Math.max(document.documentElement.clientHeight, window.innerHeight) : 0; // SSR
}

function getPlatform() {
  const userAgent = IN_BROWSER ? window.navigator.userAgent : 'ssr';

  function match(regexp) {
    return Boolean(userAgent.match(regexp));
  }

  const android = match(/android/i);
  const ios = match(/iphone|ipad|ipod/i);
  const cordova = match(/cordova/i);
  const electron = match(/electron/i);
  const chrome = match(/chrome/i);
  const edge = match(/edge/i);
  const firefox = match(/firefox/i);
  const opera = match(/opera/i);
  const win = match(/win/i);
  const mac = match(/mac/i);
  const linux = match(/linux/i);
  const ssr = match(/ssr/i);
  return {
    android,
    ios,
    cordova,
    electron,
    chrome,
    edge,
    firefox,
    opera,
    win,
    mac,
    linux,
    touch: SUPPORTS_TOUCH,
    ssr
  };
}

function createDisplay(options) {
  const {
    thresholds,
    mobileBreakpoint
  } = parseDisplayOptions(options);
  const height = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(getClientHeight());
  const platform = getPlatform();
  const state = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.reactive)({});
  const width = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(getClientWidth());

  function onResize() {
    height.value = getClientHeight();
    width.value = getClientWidth();
  } // eslint-disable-next-line max-statements


  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watchEffect)(() => {
    const xs = width.value < thresholds.sm;
    const sm = width.value < thresholds.md && !xs;
    const md = width.value < thresholds.lg && !(sm || xs);
    const lg = width.value < thresholds.xl && !(md || sm || xs);
    const xl = width.value < thresholds.xxl && !(lg || md || sm || xs);
    const xxl = width.value >= thresholds.xxl;
    const name = xs ? 'xs' : sm ? 'sm' : md ? 'md' : lg ? 'lg' : xl ? 'xl' : 'xxl';
    const breakpointValue = typeof mobileBreakpoint === 'number' ? mobileBreakpoint : thresholds[mobileBreakpoint];
    const mobile = !platform.ssr ? width.value < breakpointValue : platform.android || platform.ios || platform.opera;
    state.xs = xs;
    state.sm = sm;
    state.md = md;
    state.lg = lg;
    state.xl = xl;
    state.xxl = xxl;
    state.smAndUp = !xs;
    state.mdAndUp = !(xs || sm);
    state.lgAndUp = !(xs || sm || md);
    state.xlAndUp = !(xs || sm || md || lg);
    state.smAndDown = !(md || lg || xl || xxl);
    state.mdAndDown = !(lg || xl || xxl);
    state.lgAndDown = !(xl || xxl);
    state.xlAndDown = !xxl;
    state.name = name;
    state.height = height.value;
    state.width = width.value;
    state.mobile = mobile;
    state.mobileBreakpoint = mobileBreakpoint;
    state.platform = platform;
    state.thresholds = thresholds;
  });

  if (IN_BROWSER) {
    window.addEventListener('resize', onResize, {
      passive: true
    });
  }

  return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRefs)(state);
}
function useDisplay() {
  const display = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(DisplaySymbol);
  if (!display) throw new Error('Could not find Vuetify display injection');
  return display;
}
;// CONCATENATED MODULE: ./src/components/VBanner/VBanner.tsx

// Styles
 // Components





 // Composables










 // Utilities



/* harmony default export */ const VBanner = (defineComponent({
  name: 'VBanner',
  props: {
    avatar: String,
    color: String,
    icon: String,
    lines: {
      type: String,
      default: 'one'
    },
    sticky: Boolean,
    text: String,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-banner');
    const {
      densityClasses
    } = useDensity(props, 'v-banner');
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      mobile
    } = useDisplay();
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, 'v-banner');
    const {
      roundedClasses
    } = useRounded(props, 'v-banner');
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    return () => {
      var _slots$default;

      const hasAvatar = !!(props.avatar || props.icon || slots.avatar || slots.icon);
      const hasText = !!(props.text || slots.text);
      const hasContent = hasAvatar || hasText || slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-banner', {
          'v-banner--mobile': mobile.value,
          'v-banner--sticky': props.sticky,
          [`v-banner--${props.lines}-line`]: true
        }, borderClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, textColorClasses.value, themeClasses.value],
        "style": [dimensionStyles.value, positionStyles.value, textColorStyles.value],
        "role": "banner"
      }, {
        default: () => [hasContent && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBannerContent, null, {
          default: () => [hasAvatar && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBannerAvatar, null, {
            default: () => [slots.avatar ? slots.avatar() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VAvatar, {
              "density": props.density,
              "icon": props.icon,
              "image": props.avatar
            }, null, 8, ["density", "icon", "image"])]
          }), hasText && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBannerText, null, {
            default: () => [slots.text ? slots.text() : props.text]
          }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
          _: 1
        }), slots.actions && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBannerActions, null, {
          default: slots.actions
        })],
        _: 1
      }, 8, ["class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VBanner/index.ts





;// CONCATENATED MODULE: ./src/components/VBottomNavigation/VBottomNavigation.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VBottomNavigation/VBottomNavigation.tsx

// Styles
 // Composables









 // Utilities



/* harmony default export */ const VBottomNavigation = (defineComponent({
  name: 'VBottomNavigation',
  props: {
    bgColor: String,
    color: String,
    grow: Boolean,
    modelValue: {
      type: Boolean,
      default: true
    },
    mode: {
      type: String,
      validator: v => !v || ['horizontal', 'shift'].includes(v)
    },
    height: {
      type: [Number, String],
      default: 56
    },
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeLayoutItemProps({
      name: 'bottom-navigation'
    }),
    ...makeTagProps({
      tag: 'header'
    }),
    ...makeThemeProps()
  },
  emits: {
    'update:modelValue': value => true
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-bottom-navigation');
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => props.bgColor));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => props.color));
    const {
      densityClasses
    } = useDensity(props, 'v-bottom-navigation');
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, 'v-bottom-navigation');
    const height = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => Number(props.height) - (props.density === 'comfortable' ? 8 : 0) - (props.density === 'compact' ? 16 : 0));
    const isActive = useProxiedModel(props, 'modelValue', props.modelValue);
    const layoutStyles = useLayoutItem(props.name, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => props.priority), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => 'bottom'), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => isActive.value ? height.value : 0), height, isActive);
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-bottom-navigation', {
          'v-bottom-navigation--grow': props.grow,
          'v-bottom-navigation--horizontal': props.mode === 'horizontal',
          'v-bottom-navigation--is-active': isActive.value,
          'v-bottom-navigation--shift': props.mode === 'shift',
          'v-bottom-navigation--absolute': props.absolute
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, textColorClasses.value],
        "style": [backgroundColorStyles.value, layoutStyles.value, textColorStyles.value, {
          height: convertToUnit(height.value),
          transform: `translateY(${convertToUnit(!isActive.value ? 100 : 0, '%')})`
        }]
      }, {
        default: () => [slots.default && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-bottom-navigation__content"
        }, [slots.default()])]
      }, 8, ["class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VBottomNavigation/index.ts

;// CONCATENATED MODULE: ./src/components/VBreadcrumbs/VBreadcrumbs.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VBreadcrumbs/VBreadcrumbsItem.tsx

// Composables


 // Utilities


 // Types


/* harmony default export */ const VBreadcrumbsItem = (defineComponent({
  name: 'VBreadcrumbsItem',
  props: {
    active: Boolean,
    activeClass: String,
    activeColor: String,
    color: String,
    disabled: Boolean,
    text: String,
    ...makeRouterProps(),
    ...makeTagProps({
      tag: 'li'
    })
  },

  setup(props, {
    slots,
    attrs
  }) {
    const breadcrumbs = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(VBreadcrumbsSymbol);
    if (!breadcrumbs) throw new Error('[Vuetify] Could not find v-breadcrumbs provider');
    const link = useLink(props, attrs);
    const isActive = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _link$isExactActive;

      return props.active || ((_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value);
    });
    const color = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _props$activeColor;

      if (isActive.value) return (_props$activeColor = props.activeColor) != null ? _props$activeColor : breadcrumbs.color.value;
      return props.color;
    });
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    return () => {
      var _slots$default;

      const Tag = link.isLink.value ? 'a' : props.tag;
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(Tag, {
        "class": ['v-breadcrumbs-item', {
          'v-breadcrumbs-item--active': isActive.value,
          'v-breadcrumbs-item--disabled': props.disabled || breadcrumbs.disabled.value,
          'v-breadcrumbs-item--link': link.isLink.value,
          [`${props.activeClass}`]: isActive.value && props.activeClass
        }, textColorClasses.value],
        "style": [textColorStyles.value],
        "aria-current": isActive.value ? 'page' : undefined,
        "onClick": isActive.value && link.navigate
      }, {
        default: () => [props.text, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style", "aria-current", "onClick"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VBreadcrumbs/VBreadcrumbsDivider.tsx

/* harmony default export */ const VBreadcrumbsDivider = (createSimpleFunctional('v-breadcrumbs-divider', 'li'));
;// CONCATENATED MODULE: ./src/components/VBreadcrumbs/VBreadcrumbs.tsx

// Styles
 // Components



 // Composables




 // Utilities


 // Types

const VBreadcrumbsSymbol = Symbol.for('vuetify:breadcrumbs');
/* harmony default export */ const VBreadcrumbs = (defineComponent({
  name: 'VBreadcrumbs',
  props: {
    color: String,
    disabled: Boolean,
    divider: {
      type: String,
      default: '/'
    },
    icon: String,
    items: {
      type: Array,
      default: () => []
    },
    ...makeDensityProps(),
    ...makeRoundedProps(),
    ...makeTagProps({
      tag: 'ul'
    })
  },

  setup(props, {
    slots
  }) {
    const {
      densityClasses
    } = useDensity(props, 'v-breadcrumbs');
    const {
      roundedClasses
    } = useRounded(props, 'v-breadcrumbs');
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    const items = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      return props.items.map((item, index, array) => ({
        props: {
          disabled: index >= array.length - 1,
          ...(typeof item === 'string' ? {
            text: item
          } : item)
        }
      }));
    });
    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.provide)(VBreadcrumbsSymbol, {
      color: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'),
      disabled: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'disabled')
    });
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-breadcrumbs', densityClasses.value, roundedClasses.value, textColorClasses.value],
        "style": [textColorStyles.value]
      }, {
        default: () => [props.icon && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VIcon, {
          "icon": props.icon,
          "left": true
        }, null, 8, ["icon", "left"]), items.value.map((item, index) => {
          var _slots$item;

          return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Fragment, null, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBreadcrumbsItem, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)({
            "key": index
          }, item.props), {
            default: () => [(_slots$item = slots.item) == null ? void 0 : _slots$item.call(slots, { ...item,
              index
            })]
          }, 16), index < props.items.length - 1 && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBreadcrumbsDivider, null, {
            default: () => [slots.divider ? slots.divider({ ...item,
              index
            }) : props.divider]
          })]);
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VBreadcrumbs/index.ts



;// CONCATENATED MODULE: ./src/components/VBtn/index.ts

;// CONCATENATED MODULE: ./src/components/VCard/VCard.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VCard/VCardActions.ts

/* harmony default export */ const VCardActions = (createSimpleFunctional('v-card-actions'));
;// CONCATENATED MODULE: ./src/components/VCard/VCardAvatar.ts

/* harmony default export */ const VCardAvatar = (createSimpleFunctional('v-card-avatar'));
;// CONCATENATED MODULE: ./src/components/VCard/VCardHeader.ts

/* harmony default export */ const VCardHeader = (createSimpleFunctional('v-card-header'));
;// CONCATENATED MODULE: ./src/components/VCard/VCardHeaderText.ts

/* harmony default export */ const VCardHeaderText = (createSimpleFunctional('v-card-header-text'));
;// CONCATENATED MODULE: ./src/components/VCard/VCardImg.ts

/* harmony default export */ const VCardImg = (createSimpleFunctional('v-card-img'));
;// CONCATENATED MODULE: ./src/components/VCard/VCardMedia.ts

/* harmony default export */ const VCardMedia = (createSimpleFunctional('v-card-media'));
;// CONCATENATED MODULE: ./src/components/VCard/VCardSubtitle.ts

/* harmony default export */ const VCardSubtitle = (createSimpleFunctional('v-card-subtitle'));
;// CONCATENATED MODULE: ./src/components/VCard/VCardText.ts

/* harmony default export */ const VCardText = (createSimpleFunctional('v-card-text'));
;// CONCATENATED MODULE: ./src/components/VCard/VCardTitle.ts

/* harmony default export */ const VCardTitle = (createSimpleFunctional('v-card-title'));
;// CONCATENATED MODULE: ./src/components/VCard/VCard.tsx

// Styles
 // Components











 // Composables










 // Directives

 // Utilities


/* harmony default export */ const VCard = (defineComponent({
  name: 'VCard',
  directives: {
    Ripple: Ripple
  },
  props: {
    appendAvatar: String,
    appendIcon: String,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: Boolean,
    prependAvatar: String,
    prependIcon: String,
    ripple: Boolean,
    subtitle: String,
    text: String,
    title: String,
    ...makeThemeProps(),
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeTagProps(),
    ...makeVariantProps({
      variant: 'contained'
    })
  },

  setup(props, {
    attrs,
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-card');
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props, 'v-card');
    const {
      densityClasses
    } = useDensity(props, 'v-card');
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, 'v-card');
    const {
      roundedClasses
    } = useRounded(props, 'v-card');
    const link = useLink(props, attrs);
    return () => {
      var _slots$image, _slots$default;

      const Tag = link.isLink.value ? 'a' : props.tag;
      const hasTitle = !!(slots.title || props.title);
      const hasSubtitle = !!(slots.subtitle || props.subtitle);
      const hasHeaderText = hasTitle || hasSubtitle;
      const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
      const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
      const hasImage = !!(slots.image || props.image);
      const hasHeader = hasHeaderText || hasPrepend || hasAppend;
      const hasText = !!(slots.text || props.text);
      const isClickable = !props.disabled && (link.isClickable.value || props.link);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(Tag, {
        "class": ['v-card', {
          'v-card--disabled': props.disabled,
          'v-card--flat': props.flat,
          'v-card--hover': props.hover && !(props.disabled || props.flat),
          'v-card--link': isClickable
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value, positionStyles.value],
        "href": link.href.value,
        "onClick": isClickable && link.navigate
      }, {
        default: () => [genOverlays(isClickable, 'v-card'), hasImage && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardImg, null, {
          default: () => [slots.image ? (_slots$image = slots.image) == null ? void 0 : _slots$image.call(slots, {
            src: props.image
          }) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VImg, {
            "src": props.image,
            "alt": ""
          }, null, 8, ["src"])]
        }), slots.media && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardMedia, null, {
          default: slots.media
        }), hasHeader && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardHeader, null, {
          default: () => [hasPrepend && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardAvatar, null, {
            default: () => [slots.prepend ? slots.prepend() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VAvatar, {
              "density": props.density,
              "icon": props.prependIcon,
              "image": props.prependAvatar
            }, null, 8, ["density", "icon", "image"])]
          }), hasHeaderText && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardHeaderText, null, {
            default: () => [hasTitle && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardTitle, null, {
              default: () => [slots.title ? slots.title() : props.title]
            }), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardSubtitle, null, {
              default: () => [slots.subtitle ? slots.subtitle() : props.subtitle]
            })],
            _: 1
          }), hasAppend && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardAvatar, null, {
            default: () => [slots.append ? slots.append() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VAvatar, {
              "density": props.density,
              "icon": props.appendIcon,
              "image": props.appendAvatar
            }, null, 8, ["density", "icon", "image"])]
          })],
          _: 1
        }), hasText && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardText, null, {
          default: () => [slots.text ? slots.text() : props.text]
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), slots.actions && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VCardActions, null, {
          default: slots.actions
        })],
        _: 1
      }, 8, ["class", "style", "href", "onClick"]), [[(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDirective)("ripple"), isClickable]]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VCard/index.ts











;// CONCATENATED MODULE: ./src/components/VChip/VChip.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VChip/VChip.tsx

// Styles
 // Components


 // Composables










 // Directives

 // Utilities


/* harmony default export */ const VChip = (defineComponent({
  name: 'VChip',
  directives: {
    Ripple: Ripple
  },
  props: {
    activeClass: String,
    appendAvatar: String,
    appendIcon: String,
    closable: Boolean,
    closeIcon: {
      type: String,
      default: '$delete'
    },
    closeLabel: {
      type: String,
      default: '$vuetify.close'
    },
    disabled: Boolean,
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: '$complete'
    },
    label: Boolean,
    link: Boolean,
    pill: Boolean,
    prependAvatar: String,
    prependIcon: String,
    ripple: {
      type: Boolean,
      default: true
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeSizeProps(),
    ...makeTagProps({
      tag: 'span'
    }),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: 'contained'
    })
  },
  emits: {
    'click:close': e => e,
    'update:active': value => value
  },

  setup(props, {
    attrs,
    emit,
    slots
  }) {
    const isActive = useProxiedModel(props, 'modelValue');
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-chip');
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props, 'v-chip');
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, 'v-chip');
    const {
      sizeClasses
    } = useSize(props, 'v-chip');
    const {
      densityClasses
    } = useDensity(props, 'v-chip');
    const link = useLink(props, attrs);

    function onCloseClick(e) {
      isActive.value = false;
      emit('click:close', e);
    }

    return () => {
      var _slots$default;

      const Tag = link.isLink.value ? 'a' : props.tag;
      const hasAppend = !!(slots.append || props.appendIcon || props.appendAvatar);
      const hasClose = !!(slots.close || props.closable);
      const hasPrepend = !!(slots.prepend || props.prependIcon || props.prependAvatar);
      const isClickable = !props.disabled && (link.isClickable.value || props.link);
      return isActive.value && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(Tag, {
        "class": ['v-chip', {
          'v-chip--disabled': props.disabled,
          'v-chip--label': props.label,
          'v-chip--link': isClickable,
          'v-chip--pill': props.pill
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value],
        "style": [colorStyles.value],
        "disabled": props.disabled || undefined,
        "draggable": props.draggable,
        "href": link.href.value,
        "onClick": isClickable && link.navigate
      }, {
        default: () => [genOverlays(isClickable, 'v-chip'), hasPrepend && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-chip__prepend"
        }, [slots.prepend ? slots.prepend() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VAvatar, {
          "icon": props.prependIcon,
          "image": props.prependAvatar,
          "size": props.size
        }, null, 8, ["icon", "image", "size"])]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), hasAppend && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-chip__append"
        }, [slots.append ? slots.append() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VAvatar, {
          "icon": props.appendIcon,
          "image": props.appendAvatar,
          "size": props.size
        }, null, 8, ["icon", "image", "size"])]), hasClose && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-chip__close",
          "onClick": onCloseClick
        }, [slots.close ? slots.close({
          props: {
            onClick: onCloseClick
          }
        }) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VIcon, {
          "icon": props.closeIcon,
          "size": "x-small"
        }, null, 8, ["icon"])], 8, ["onClick"])],
        _: 1
      }, 8, ["class", "style", "disabled", "draggable", "href", "onClick"]), [[(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDirective)("ripple"), isClickable && props.ripple, null]]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VChip/index.ts

;// CONCATENATED MODULE: ./src/components/VCode/VCode.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VCode/index.ts


const VCode = createSimpleFunctional('v-code');
;// CONCATENATED MODULE: ./src/components/VDefaultsProvider/VDefaultsProvider.tsx


/* harmony default export */ const VDefaultsProvider = ((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.defineComponent)({
  props: {
    defaults: Object
  },

  setup(props, {
    slots
  }) {
    provideDefaults(props);
    return () => {
      var _slots$default;

      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VDefaultsProvider/index.ts

;// CONCATENATED MODULE: ./src/components/VDialog/VDialog.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/util/easing.ts
const standardEasing = 'cubic-bezier(0.4, 0, 0.2, 1)';
const deceleratedEasing = 'cubic-bezier(0.0, 0, 0.2, 1)'; // Entering

const acceleratedEasing = 'cubic-bezier(0.4, 0, 1, 1)'; // Leaving
;// CONCATENATED MODULE: ./src/components/transitions/dialog-transition.tsx



/* harmony default export */ const dialog_transition = (defineComponent({
  name: 'VDialogTransition',
  props: {
    target: Object
  },

  setup(props, {
    slots
  }) {
    const functions = {
      onEnter(el, done) {
        const {
          x,
          y
        } = getDimensions(props.target, el);
        const animation = el.animate([{
          transform: `translate(${x}px, ${y}px) scale(0.1)`,
          opacity: 0
        }, {
          transform: ''
        }], {
          duration: 225,
          easing: deceleratedEasing
        });
        animation.finished.then(() => done());
      },

      onLeave(el, done) {
        const {
          x,
          y
        } = getDimensions(props.target, el);
        const animation = el.animate([{
          transform: ''
        }, {
          transform: `translate(${x}px, ${y}px) scale(0.1)`,
          opacity: 0
        }], {
          duration: 125,
          easing: acceleratedEasing
        });
        animation.finished.then(() => done());
      }

    };
    return () => {
      return props.target ? (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Transition, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)({
        "name": "dialog-transition"
      }, functions, {
        "css": false
      }), slots, 16) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Transition, {
        "name": "dialog-transition"
      }, slots);
    };
  }

}));

function getDimensions(target, el) {
  const initialDisplay = el.style.display;
  const initialTransform = el.style.transform;
  el.style.transition = 'none';
  el.style.display = '';
  el.style.transform = 'none';
  const targetBox = target.getBoundingClientRect();
  const elBox = el.getBoundingClientRect();
  const x = targetBox.width / 2 + targetBox.left - (elBox.width / 2 + elBox.left);
  const y = targetBox.height / 2 + targetBox.top - (elBox.height / 2 + elBox.top);
  el.style.display = initialDisplay;
  el.style.transform = initialTransform;
  return {
    x,
    y
  };
}
;// CONCATENATED MODULE: ./src/components/VOverlay/VOverlay.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/composables/teleport.ts

function useTeleport(target) {
  const teleportTarget = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    const _target = target.value;
    if (_target === true) return undefined;
    const targetElement = _target === false ? document.body : typeof _target === 'string' ? document.querySelector(_target) : _target;

    if (targetElement == null) {
      (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.warn)(`Unable to locate target ${_target}`);
      return undefined;
    }

    if (!useTeleport.cache.has(targetElement)) {
      const el = document.createElement('div');
      el.className = 'v-overlay-container';
      targetElement.appendChild(el);
      useTeleport.cache.set(targetElement, el);
    }

    return useTeleport.cache.get(targetElement);
  });
  return {
    teleportTarget
  };
}
useTeleport.cache = new WeakMap();
;// CONCATENATED MODULE: ./src/util/dom.ts
/**
 * Returns:
 *  - 'null' if the node is not attached to the DOM
 *  - the root node (HTMLDocument | ShadowRoot) otherwise
 */
function attachedRoot(node) {
  /* istanbul ignore next */
  if (typeof node.getRootNode !== 'function') {
    // Shadow DOM not supported (IE11), lets find the root of this node
    while (node.parentNode) node = node.parentNode; // The root parent is the document if the node is attached to the DOM


    if (node !== document) return null;
    return document;
  }

  const root = node.getRootNode(); // The composed root node is the document if the node is attached to the DOM

  if (root !== document && root.getRootNode({
    composed: true
  }) !== document) return null;
  return root;
}
;// CONCATENATED MODULE: ./src/directives/click-outside/index.ts


function defaultConditional() {
  return true;
}

function checkEvent(e, el, binding) {
  // The include element callbacks below can be expensive
  // so we should avoid calling them when we're not active.
  // Explicitly check for false to allow fallback compatibility
  // with non-toggleable components
  if (!e || checkIsActive(e, binding) === false) return false; // If we're clicking inside the shadowroot, then the app root doesn't get the same
  // level of introspection as to _what_ we're clicking. We want to check to see if
  // our target is the shadowroot parent container, and if it is, ignore.

  const root = attachedRoot(el);
  if (root instanceof ShadowRoot && root.host === e.target) return false; // Check if additional elements were passed to be included in check
  // (click must be outside all included elements, if any)

  const elements = (typeof binding.value === 'object' && binding.value.include || (() => []))(); // Add the root element for the component this directive was defined on


  elements.push(el); // Check if it's a click outside our elements, and then if our callback returns true.
  // Non-toggleable components should take action in their callback and return falsy.
  // Toggleable can return true if it wants to deactivate.
  // Note that, because we're in the capture phase, this callback will occur before
  // the bubbling click event on any outside elements.

  return !elements.some(el => el.contains(e.target));
}

function checkIsActive(e, binding) {
  const isActive = typeof binding.value === 'object' && binding.value.closeConditional || defaultConditional;
  return isActive(e);
}

function directive(e, el, binding) {
  const handler = typeof binding.value === 'function' ? binding.value : binding.value.handler;
  el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(() => {
    checkIsActive(e, binding) && handler && handler(e);
  }, 0);
}

function handleShadow(el, callback) {
  const root = attachedRoot(el);
  callback(document.body);

  if (root instanceof ShadowRoot) {
    callback(root);
  }
}

const ClickOutside = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(el, binding) {
    const onClick = e => directive(e, el, binding);

    const onMousedown = e => {
      el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
    };

    handleShadow(el, app => {
      app.addEventListener('click', onClick, true);
      app.addEventListener('mousedown', onMousedown, true);
    });
    el._clickOutside = {
      lastMousedownWasOutside: true,
      onClick,
      onMousedown
    };
  },

  unmounted(el) {
    if (!el._clickOutside) return;
    handleShadow(el, app => {
      if (!app || !el._clickOutside) return;
      app.removeEventListener('click', el._clickOutside.onClick, true);
      app.removeEventListener('mousedown', el._clickOutside.onMousedown, true);
    });
    delete el._clickOutside;
  }

};
/* harmony default export */ const click_outside = ((/* unused pure expression or super */ null && (ClickOutside)));
;// CONCATENATED MODULE: ./src/util/getScrollParent.ts
function getScrollParent(el) {
  while (el) {
    if (hasScrollbar(el)) return el;
    el = el.parentElement;
  }

  return document.scrollingElement;
}
function getScrollParents(el) {
  const elements = [];

  while (el) {
    if (hasScrollbar(el)) elements.push(el);
    el = el.parentElement;
  }

  return elements;
}

function hasScrollbar(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
  const style = window.getComputedStyle(el);
  return style.overflowY === 'scroll' || style.overflowY === 'auto' && el.scrollHeight > el.clientHeight;
}
;// CONCATENATED MODULE: ./src/components/VOverlay/VOverlay.tsx


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Styles
 // Composables







 // Directives

 // Utilities


 // Types

function useBooted(isActive, eager) {
  const isBooted = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(eager.value);
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watchEffect)(() => {
    if (eager.value || isActive.value) {
      isBooted.value = true;
    }
  });
  return {
    isBooted
  };
}

const positionStrategies = ['global', // specific viewport position, usually centered
'connected', // connected to a certain element
'flexible' // connected to an element with the ability to overflow or shift if it doesn't fit in the screen
];
const scrollStrategies = ['close', 'block', 'reposition'];

function Scrim(props) {
  const {
    modelValue,
    color,
    ...rest
  } = props;
  return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Transition, {
    "name": "fade-transition",
    "appear": true
  }, {
    default: () => [props.modelValue && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)({
      "class": ['v-overlay__scrim', props.color.backgroundColorClasses.value],
      "style": props.color.backgroundColorStyles.value
    }, rest), null, 16)]
  }, 8, ["appear"]);
}

class CloseScrollStrategy {
  constructor({
    content,
    isActive
  }) {
    _defineProperty(this, "scrollElements", []);

    this.content = content;
    this.isActive = isActive;
  }

  enable() {
    this.scrollElements = [document, ...getScrollParents(this.content.value)];
    this.scrollElements.forEach(el => {
      el.addEventListener('scroll', this.onScroll.bind(this), {
        passive: true
      });
    });
  }

  disable() {
    this.scrollElements.forEach(el => {
      el.removeEventListener('scroll', this.onScroll.bind(this));
    });
  }

  onScroll() {
    this.isActive.value = false;
  }

}

class BlockScrollStrategy {
  constructor({
    content
  }) {
    _defineProperty(this, "initialOverflow", []);

    _defineProperty(this, "scrollElements", []);

    this.content = content;
  }

  enable() {
    this.scrollElements = getScrollParents(this.content.value);
    const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
    document.documentElement.style.setProperty('--v-scrollbar-offset', convertToUnit(scrollbarWidth));
    this.scrollElements.forEach((el, i) => {
      this.initialOverflow[i] = el.style.overflowY;
      el.style.overflowY = 'hidden';
      el.style.setProperty('--v-scrollbar-offset', convertToUnit(scrollbarWidth));
    });
  }

  disable() {
    this.scrollElements.forEach((el, i) => {
      el.style.overflowY = this.initialOverflow[i];
      el.style.removeProperty('--v-scrollbar-offset');
    });
    document.documentElement.style.removeProperty('--v-scrollbar-offset');
  }

}

/* harmony default export */ const VOverlay = (defineComponent({
  name: 'VOverlay',
  directives: {
    ClickOutside: ClickOutside
  },
  inheritAttrs: false,
  props: {
    absolute: Boolean,
    attach: {
      type: [Boolean, String, Object],
      default: 'body'
    },
    eager: Boolean,
    noClickAnimation: Boolean,
    modelValue: Boolean,
    origin: [String, Object],
    persistent: Boolean,
    positionStrategy: {
      type: String,
      default: 'global',
      validator: val => positionStrategies.includes(val)
    },
    scrim: {
      type: [String, Boolean],
      default: true
    },
    scrollStrategy: {
      type: String,
      default: 'block',
      validator: val => scrollStrategies.includes(val)
    },
    ...makeThemeProps(),
    ...makeTransitionProps()
  },
  emits: {
    'click:outside': e => true,
    'update:modelValue': value => true
  },

  setup(props, {
    slots,
    attrs,
    emit
  }) {
    const isActive = useProxiedModel(props, 'modelValue');
    const {
      teleportTarget
    } = useTeleport((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'attach'));
    const {
      themeClasses
    } = useTheme(props);
    const {
      rtlClasses
    } = useRtl();
    const {
      isBooted
    } = useBooted(isActive, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'eager'));
    const scrimColor = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      return typeof props.scrim === 'string' ? props.scrim : null;
    }));

    function onClickOutside(e) {
      emit('click:outside', e);
      if (!props.persistent) isActive.value = false;else animateClick();
    }

    function closeConditional() {
      return isActive.value;
    }

    const activatorElement = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();

    function onActivatorClick(e) {
      activatorElement.value = e.currentTarget || e.target;
      isActive.value = !isActive.value;
    }

    function onKeydown(e) {
      if (e.key === 'Escape') {
        if (!props.persistent) {
          isActive.value = false;
        } else animateClick();
      }
    }

    useBackButton(next => {
      next(!isActive.value);
      if (!props.persistent) isActive.value = false;else animateClick();
    });
    const content = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(isActive, val => {
      (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.nextTick)(() => {
        if (val) {
          var _content$value;

          (_content$value = content.value) == null ? void 0 : _content$value.focus();
        } else {
          var _activatorElement$val;

          (_activatorElement$val = activatorElement.value) == null ? void 0 : _activatorElement$val.focus();
        }
      });
    });
    const root = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
    const top = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(() => isActive.value && props.absolute && teleportTarget.value == null, val => {
      if (val) {
        const scrollParent = getScrollParent(root.value);

        if (scrollParent && scrollParent !== document.scrollingElement) {
          top.value = scrollParent.scrollTop;
        }
      }
    }); // Add a quick "bounce" animation to the content

    function animateClick() {
      var _content$value2;

      if (props.noClickAnimation) return;
      (_content$value2 = content.value) == null ? void 0 : _content$value2.animate([{
        transformOrigin: 'center'
      }, {
        transform: 'scale(1.03)'
      }, {
        transformOrigin: 'center'
      }], {
        duration: 150,
        easing: standardEasing
      });
    }

    function onAfterLeave() {
      if (!props.eager) isBooted.value = false;
    }

    const scrollStrategy = props.scrollStrategy === 'close' ? new CloseScrollStrategy({
      content,
      isActive
    }) : props.scrollStrategy === 'block' ? new BlockScrollStrategy({
      content
    }) : null; // TODO: reactive

    if (scrollStrategy) {
      (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(isActive, val => {
        (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.nextTick)(() => {
          val ? scrollStrategy.enable() : scrollStrategy.disable();
        });
      });
    }

    useRender(() => {
      var _slots$activator, _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Fragment, null, [(_slots$activator = slots.activator) == null ? void 0 : _slots$activator.call(slots, {
        isActive: isActive.value,
        props: {
          modelValue: isActive.value,
          'onUpdate:modelValue': val => isActive.value = val,
          onClick: onActivatorClick
        }
      }), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Teleport, {
        "disabled": !teleportTarget.value,
        "ref": root,
        "to": teleportTarget.value
      }, {
        default: () => [isBooted.value && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)({
          "class": ['v-overlay', {
            'v-overlay--absolute': props.absolute,
            'v-overlay--active': isActive.value
          }, themeClasses.value, rtlClasses.value],
          "style": top.value != null ? `top: ${convertToUnit(top.value)}` : undefined
        }, attrs), [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(Scrim, {
          "color": scrimColor,
          "modelValue": isActive.value && !!props.scrim
        }, null, 8, ["color", "modelValue"]), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(MaybeTransition, {
          "appear": true,
          "onAfterLeave": onAfterLeave,
          "persisted": true,
          "transition": props.transition
        }, {
          default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
            "ref": content,
            "class": "v-overlay__content",
            "tabindex": -1,
            "onKeydown": onKeydown
          }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
            isActive
          })], 40, ["tabindex", "onKeydown"]), [[external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.vShow, isActive.value], [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDirective)("click-outside"), {
            handler: onClickOutside,
            closeConditional
          }]])]
        }, 8, ["appear", "onAfterLeave", "persisted", "transition"])], 16)]
      }, 8, ["disabled", "to"])]);
    });
    return {
      animateClick,
      content
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VDialog/VDialog.tsx

// Styles
 // Components


 // Composables



 // Utilities



/* harmony default export */ const VDialog = (defineComponent({
  name: 'VDialog',
  props: {
    fullscreen: Boolean,
    origin: {
      type: String,
      default: 'center center'
    },
    retainFocus: {
      type: Boolean,
      default: true
    },
    scrollable: Boolean,
    modelValue: Boolean,
    ...makeDimensionProps({
      width: 'auto'
    }),
    ...makeTransitionProps({
      transition: {
        component: dialog_transition
      }
    })
  },
  emits: {
    'update:modelValue': value => true
  },

  setup(props, {
    attrs,
    slots
  }) {
    const isActive = useProxiedModel(props, 'modelValue');
    const {
      dimensionStyles
    } = useDimension(props);
    const overlay = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();

    function onFocusin(e) {
      var _overlay$value;

      const before = e.relatedTarget;
      const after = e.target;

      if (before !== after && (_overlay$value = overlay.value) != null && _overlay$value.content && // It isn't the document or the dialog body
      ![document, overlay.value.content].includes(after) && // It isn't inside the dialog body
      !overlay.value.content.contains(after) // We're the topmost dialog
      // TODO: this.activeZIndex >= this.getMaxZIndex() &&
      // It isn't inside a dependent element (like a menu)
      // TODO: !this.getOpenDependentElements().some(el => el.contains(target))
      // So we must have focused something outside the dialog and its children
      ) {
          const focusable = [...overlay.value.content.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter(el => !el.hasAttribute('disabled'));
          if (!focusable.length) return;
          const firstElement = focusable[0];
          const lastElement = focusable[focusable.length - 1];

          if (before === firstElement) {
            lastElement.focus();
          } else {
            firstElement.focus();
          }
        }
    }

    if (IN_BROWSER) {
      (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(() => isActive.value && props.retainFocus, val => {
        val ? document.addEventListener('focusin', onFocusin) : document.removeEventListener('focusin', onFocusin);
      }, {
        immediate: true
      });
    }

    const activatorElement = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();

    const activator = ({
      props,
      ...data
    }) => {
      var _slots$activator;

      return (_slots$activator = slots.activator) == null ? void 0 : _slots$activator.call(slots, { ...data,
        props: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)(props, {
          'aria-haspopup': 'dialog',
          onClick: e => {
            activatorElement.value = e.currentTarget;
          }
        })
      });
    };

    return () => {
      const transition = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)({
        target: activatorElement.value
      }, typeof props.transition === 'string' ? {
        name: props.transition
      } : props.transition);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VOverlay, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.mergeProps)({
        "modelValue": isActive.value,
        "onUpdate:modelValue": $event => isActive.value = $event,
        "class": ['v-dialog', {
          'v-dialog--fullscreen': props.fullscreen
        }],
        "style": dimensionStyles.value,
        "transition": transition,
        "ref": overlay,
        "aria-role": "dialog",
        "aria-modal": "true"
      }, attrs), {
        default: slots.default,
        activator
      }, 16, ["modelValue", "onUpdate:modelValue", "class", "style", "transition"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VDialog/index.ts


;// CONCATENATED MODULE: ./src/components/VDivider/VDivider.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VDivider/VDivider.tsx

// Styles
 // Utilities


 // Composables

 // Types

/* harmony default export */ const VDivider = (defineComponent({
  name: 'VDivider',
  props: {
    inset: Boolean,
    length: [Number, String],
    thickness: [Number, String],
    vertical: Boolean,
    ...makeThemeProps()
  },

  setup(props, {
    attrs
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const dividerStyles = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      const styles = {};

      if (props.length) {
        styles[props.vertical ? 'maxHeight' : 'maxWidth'] = convertToUnit(props.length);
      }

      if (props.thickness) {
        styles[props.vertical ? 'borderRightWidth' : 'borderTopWidth'] = convertToUnit(props.thickness);
      }

      return styles;
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("hr", {
        "class": [{
          'v-divider': true,
          'v-divider--inset': props.inset,
          'v-divider--vertical': props.vertical
        }, themeClasses.value],
        "style": dividerStyles.value,
        "aria-orientation": !attrs.role || attrs.role === 'separator' ? props.vertical ? 'vertical' : 'horizontal' : undefined,
        "role": `${attrs.role || 'separator'}`
      }, null, 14, ["aria-orientation"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VDivider/index.ts

;// CONCATENATED MODULE: ./src/components/VFooter/VFooter.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VFooter/VFooter.tsx

// Styles
 // Composables







 // Utilities


/* harmony default export */ const VFooter = (defineComponent({
  name: 'VFooter',
  props: { ...makeBorderProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeTagProps({
      tag: 'footer'
    }),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-footer');
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, 'v-footer');
    const {
      roundedClasses
    } = useRounded(props, 'v-footer');
    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
      "class": ['v-footer', themeClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value],
      "style": [dimensionStyles.value, positionStyles.value]
    }, slots, 8, ["class", "style"]);
  }

}));
;// CONCATENATED MODULE: ./src/components/VFooter/index.ts

;// CONCATENATED MODULE: ./src/components/VGrid/VGrid.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VGrid/VContainer.tsx

// Styles
 // Composables

 // Utilities


/* harmony default export */ const VContainer = (defineComponent({
  name: 'VContainer',
  props: {
    fluid: {
      type: Boolean,
      default: false
    },
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
      "class": ['v-container', {
        'v-container--fluid': props.fluid
      }]
    }, slots, 8, ["class"]);
  }

}));
;// CONCATENATED MODULE: ./src/components/VGrid/VCol.ts
// Styles
 // Composables

 // Utilities


 // Types

const breakpoints = ['sm', 'md', 'lg', 'xl', 'xxl']; // no xs

const breakpointProps = (() => {
  return breakpoints.reduce((props, val) => {
    props[val] = {
      type: [Boolean, String, Number],
      default: false
    };
    return props;
  }, {});
})();

const offsetProps = (() => {
  return breakpoints.reduce((props, val) => {
    props['offset' + (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.capitalize)(val)] = {
      type: [String, Number],
      default: null
    };
    return props;
  }, {});
})();

const orderProps = (() => {
  return breakpoints.reduce((props, val) => {
    props['order' + (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.capitalize)(val)] = {
      type: [String, Number],
      default: null
    };
    return props;
  }, {});
})();

const propMap = {
  col: Object.keys(breakpointProps),
  offset: Object.keys(offsetProps),
  order: Object.keys(orderProps)
};

function breakpointClass(type, prop, val) {
  let className = type;

  if (val == null || val === false) {
    return undefined;
  }

  if (prop) {
    const breakpoint = prop.replace(type, '');
    className += `-${breakpoint}`;
  }

  if (type === 'col') {
    className = 'v-' + className;
  } // Handling the boolean style prop when accepting [Boolean, String, Number]
  // means Vue will not convert <v-col sm></v-col> to sm: true for us.
  // Since the default is false, an empty string indicates the prop's presence.


  if (type === 'col' && (val === '' || val === true)) {
    // .v-col-md
    return className.toLowerCase();
  } // .order-md-6


  className += `-${val}`;
  return className.toLowerCase();
}

/* harmony default export */ const VCol = (defineComponent({
  name: 'VCol',
  props: {
    cols: {
      type: [Boolean, String, Number],
      default: false
    },
    ...breakpointProps,
    offset: {
      type: [String, Number],
      default: null
    },
    ...offsetProps,
    order: {
      type: [String, Number],
      default: null
    },
    ...orderProps,
    alignSelf: {
      type: String,
      default: null,
      validator: str => ['auto', 'start', 'end', 'center', 'baseline', 'stretch'].includes(str)
    },
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    const classes = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      const classList = []; // Loop through `col`, `offset`, `order` breakpoint props

      let type;

      for (type in propMap) {
        propMap[type].forEach(prop => {
          const value = props[prop];
          const className = breakpointClass(type, prop, value);
          if (className) classList.push(className);
        });
      }

      const hasColClasses = classList.some(className => className.startsWith('v-col-'));
      classList.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        'v-col': !hasColClasses || !props.cols,
        [`v-col-${props.cols}`]: props.cols,
        [`offset-${props.offset}`]: props.offset,
        [`order-${props.order}`]: props.order,
        [`align-self-${props.alignSelf}`]: props.alignSelf
      });
      return classList;
    });
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(props.tag, {
        class: classes.value
      }, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots));
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VGrid/VRow.ts
// Styles
 // Composables

 // Utilities


 // Types

const VRow_breakpoints = ['sm', 'md', 'lg', 'xl', 'xxl']; // no xs

const ALIGNMENT = ['start', 'end', 'center'];

function makeRowProps(prefix, def) {
  return VRow_breakpoints.reduce((props, val) => {
    props[prefix + (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.capitalize)(val)] = def();
    return props;
  }, {});
}

const alignValidator = str => [...ALIGNMENT, 'baseline', 'stretch'].includes(str);

const alignProps = makeRowProps('align', () => ({
  type: String,
  default: null,
  validator: alignValidator
}));

const justifyValidator = str => [...ALIGNMENT, 'space-between', 'space-around'].includes(str);

const justifyProps = makeRowProps('justify', () => ({
  type: String,
  default: null,
  validator: justifyValidator
}));

const alignContentValidator = str => [...ALIGNMENT, 'space-between', 'space-around', 'stretch'].includes(str);

const alignContentProps = makeRowProps('alignContent', () => ({
  type: String,
  default: null,
  validator: alignContentValidator
}));
const VRow_propMap = {
  align: Object.keys(alignProps),
  justify: Object.keys(justifyProps),
  alignContent: Object.keys(alignContentProps)
};
const classMap = {
  align: 'align',
  justify: 'justify',
  alignContent: 'align-content'
};

function VRow_breakpointClass(type, prop, val) {
  let className = classMap[type];

  if (val == null) {
    return undefined;
  }

  if (prop) {
    // alignSm -> Sm
    const breakpoint = prop.replace(type, '');
    className += `-${breakpoint}`;
  } // .align-items-sm-center


  className += `-${val}`;
  return className.toLowerCase();
}

/* harmony default export */ const VRow = (defineComponent({
  name: 'VRow',
  props: {
    dense: Boolean,
    noGutters: Boolean,
    align: {
      type: String,
      default: null,
      validator: alignValidator
    },
    ...alignProps,
    justify: {
      type: String,
      default: null,
      validator: justifyValidator
    },
    ...justifyProps,
    alignContent: {
      type: String,
      default: null,
      validator: alignContentValidator
    },
    ...alignContentProps,
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    const classes = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      const classList = []; // Loop through `align`, `justify`, `alignContent` breakpoint props

      let type;

      for (type in VRow_propMap) {
        VRow_propMap[type].forEach(prop => {
          const value = props[prop];
          const className = VRow_breakpointClass(type, prop, value);
          if (className) classList.push(className);
        });
      }

      classList.push({
        'v-row--no-gutters': props.noGutters,
        'v-row--dense': props.dense,
        [`align-${props.align}`]: props.align,
        [`justify-${props.justify}`]: props.justify,
        [`align-content-${props.alignContent}`]: props.alignContent
      });
      return classList;
    });
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(props.tag, {
        class: ['v-row', classes.value]
      }, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots));
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VGrid/VSpacer.ts

/* harmony default export */ const VSpacer = (createSimpleFunctional('flex-grow-1', 'div', 'VSpacer'));
;// CONCATENATED MODULE: ./src/components/VGrid/index.ts




;// CONCATENATED MODULE: ./src/components/VIcon/index.ts


;// CONCATENATED MODULE: ./src/components/VImg/index.ts

;// CONCATENATED MODULE: ./src/components/VKbd/VKbd.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VKbd/index.ts


const VKbd = createSimpleFunctional('v-kbd');
;// CONCATENATED MODULE: ./src/components/VItemGroup/VItemGroup.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/composables/group.ts
// Utilities


 // Types

const makeGroupProps = propsFactory({
  modelValue: {
    type: [Number, Boolean, String, Array, Object],
    default: undefined
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String
}, 'group');
const makeGroupItemProps = propsFactory({
  value: {
    type: [Number, Boolean, String, Object],
    default: undefined
  },
  index: Number,
  disabled: Boolean,
  selectedClass: String
}, 'group-item'); // Composables

function useGroupItem(props, injectKey) {
  const group = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(injectKey, null);

  if (!group) {
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
  }

  const id = getUid();
  const value = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'value');
  const disabled = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'disabled');
  group.register({
    id,
    value,
    disabled
  }, props.index);
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeUnmount)(() => {
    group.unregister(id);
  });
  const isSelected = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    return group.isSelected(id);
  });
  const selectedClass = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
    var _group$selectedClass$;

    return isSelected.value && ((_group$selectedClass$ = group.selectedClass.value) != null ? _group$selectedClass$ : props.selectedClass);
  });
  return {
    isSelected,
    toggle: () => group.select(id, !isSelected.value),
    select: value => group.select(id, value),
    selectedClass,
    value,
    disabled
  };
}
function useGroup(props, injectKey) {
  let isUnmounted = false;
  const items = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.reactive)([]);
  const selected = useProxiedModel(props, 'modelValue', [], v => {
    if (v == null) return [];
    return getIds(items, wrapInArray(v));
  }, v => {
    const arr = getValues(items, v);
    return props.multiple ? arr : arr[0];
  });

  function register(item, index) {
    // Is there a better way to fix this typing?
    const unwrapped = item;
    if (index != null) items.splice(index, 0, unwrapped);else items.push(unwrapped);
  }

  function unregister(id) {
    if (isUnmounted) return;
    selected.value = selected.value.filter(v => v !== id);
    forceMandatoryValue();
    const index = items.findIndex(item => item.id === id);
    items.splice(index, 1);
  } // If mandatory and nothing is selected, then select first non-disabled item


  function forceMandatoryValue() {
    const item = items.find(item => !item.disabled);

    if (item && props.mandatory === 'force' && !selected.value.length) {
      selected.value = [item.id];
    }
  }

  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onMounted)(() => {
    forceMandatoryValue();
  });
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeUnmount)(() => {
    isUnmounted = true;
  });

  function select(id, isSelected) {
    const item = items.find(item => item.id === id);
    if (isSelected && item != null && item.disabled) return;

    if (props.multiple) {
      const internalValue = selected.value.slice();
      const index = internalValue.findIndex(v => v === id); // We can't remove value if group is
      // mandatory, value already exists,
      // and it is the only value

      if (props.mandatory && index > -1 && internalValue.length <= 1) return; // We can't add value if it would
      // cause max limit to be exceeded

      if (props.max != null && index < 0 && internalValue.length + 1 > props.max) return;
      if (index < 0 && isSelected) internalValue.push(id);else if (index >= 0 && !isSelected) internalValue.splice(index, 1);
      selected.value = internalValue;
    } else {
      if (props.mandatory && selected.value.includes(id)) return;
      selected.value = isSelected ? [id] : [];
    }
  }

  function step(offset) {
    // getting an offset from selected value obviously won't work with multiple values
    if (props.multiple) consoleWarn('This method is not supported when using "multiple" prop');

    if (!selected.value.length) {
      const item = items.find(item => !item.disabled);
      item && (selected.value = [item.id]);
    } else {
      const currentId = selected.value[0];
      const currentIndex = items.findIndex(i => i.id === currentId);
      let newIndex = (currentIndex + offset) % items.length;
      let newItem = items[newIndex];

      while (newItem.disabled && newIndex !== currentIndex) {
        newIndex = (newIndex + offset) % items.length;
        newItem = items[newIndex];
      }

      if (newItem.disabled) return;
      selected.value = [items[newIndex].id];
    }
  }

  const state = {
    register,
    unregister,
    selected,
    select,
    prev: () => step(items.length - 1),
    next: () => step(1),
    isSelected: id => selected.value.includes(id),
    selectedClass: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => props.selectedClass)
  };
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.provide)(injectKey, state);
  return state;
}

function getIds(items, modelValue) {
  const ids = [];

  for (const item of items) {
    if (item.value != null) {
      if (modelValue.find(value => deepEqual(value, item.value))) {
        ids.push(item.id);
      }
    } else if (modelValue.includes(item.id)) {
      ids.push(item.id);
    }
  }

  return ids;
}

function getValues(items, ids) {
  const values = [];

  for (const item of items) {
    if (ids.includes(item.id)) {
      values.push(item.value != null ? item.value : item.id);
    }
  }

  return values;
}
;// CONCATENATED MODULE: ./src/components/VItemGroup/VItemGroup.tsx

// Styles
 // Composables



 // Utilities


const VItemGroupSymbol = Symbol.for('vuetify:v-item-group');
/* harmony default export */ const VItemGroup = (defineComponent({
  name: 'VItemGroup',
  props: { ...makeGroupProps({
      selectedClass: 'v-item--selected'
    }),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  emits: {
    'update:modelValue': value => true
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props, VItemGroupSymbol);
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-item-group', themeClasses.value]
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })]
      }, 8, ["class"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VItemGroup/VItem.tsx
// Composables

 // Utilities


/* harmony default export */ const VItem = (defineComponent({
  name: 'VItem',
  props: makeGroupItemProps(),

  setup(props, {
    slots
  }) {
    const {
      isSelected,
      select,
      toggle,
      selectedClass,
      value,
      disabled
    } = useGroupItem(props, VItemGroupSymbol);
    return () => {
      var _slots$default;

      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        isSelected: isSelected.value,
        selectedClass: selectedClass.value,
        select,
        toggle,
        value: value.value,
        disabled: disabled.value
      });
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VItemGroup/index.ts


;// CONCATENATED MODULE: ./src/components/VLayout/VLayout.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VLayout/VLayout.tsx

// Styles
 // Utilities

 // Composables


/* harmony default export */ const VLayout = (defineComponent({
  name: 'VLayout',
  props: makeLayoutProps(),

  setup(props, {
    slots
  }) {
    const {
      layoutClasses,
      getLayoutItem,
      items
    } = createLayout(props);
    useRender(() => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": layoutClasses.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 2);
    });
    return {
      getLayoutItem,
      items
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VLayout/VLayoutItem.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VLayout/VLayoutItem.tsx

// Styles
 // Composables

 // Utilities


 // Types

/* harmony default export */ const VLayoutItem = (defineComponent({
  name: 'VLayoutItem',
  props: {
    position: {
      type: String,
      required: true
    },
    size: {
      type: [Number, String],
      default: 300
    },
    modelValue: Boolean,
    ...makeLayoutItemProps()
  },

  setup(props, {
    slots
  }) {
    const styles = useLayoutItem(props.name, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'priority'), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'position'), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'size'), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'size'), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'modelValue'));
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": ['v-layout-item', {
          'v-layout-item--absolute': props.absolute
        }],
        "style": styles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 6);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VLayout/index.ts


;// CONCATENATED MODULE: ./src/components/VLocaleProvider/VLocaleProvider.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/locale/en.ts
/* harmony default export */ const en = ({
  badge: 'Badge',
  close: 'Close',
  dataIterator: {
    noResultsText: 'No matching records found',
    loadingText: 'Loading items...'
  },
  dataTable: {
    itemsPerPageText: 'Rows per page:',
    ariaLabel: {
      sortDescending: 'Sorted descending.',
      sortAscending: 'Sorted ascending.',
      sortNone: 'Not sorted.',
      activateNone: 'Activate to remove sorting.',
      activateDescending: 'Activate to sort descending.',
      activateAscending: 'Activate to sort ascending.'
    },
    sortBy: 'Sort by'
  },
  dataFooter: {
    itemsPerPageText: 'Items per page:',
    itemsPerPageAll: 'All',
    nextPage: 'Next page',
    prevPage: 'Previous page',
    firstPage: 'First page',
    lastPage: 'Last page',
    pageText: '{0}-{1} of {2}'
  },
  datePicker: {
    itemsSelected: '{0} selected',
    nextMonthAriaLabel: 'Next month',
    nextYearAriaLabel: 'Next year',
    prevMonthAriaLabel: 'Previous month',
    prevYearAriaLabel: 'Previous year'
  },
  noDataText: 'No data available',
  carousel: {
    prev: 'Previous visual',
    next: 'Next visual',
    ariaLabel: {
      delimiter: 'Carousel slide {0} of {1}'
    }
  },
  calendar: {
    moreEvents: '{0} more'
  },
  fileInput: {
    counter: '{0} files',
    counterSize: '{0} files ({1} in total)'
  },
  timePicker: {
    am: 'AM',
    pm: 'PM'
  },
  pagination: {
    ariaLabel: {
      root: 'Pagination Navigation',
      next: 'Next page',
      previous: 'Previous page',
      page: 'Goto Page {0}',
      currentPage: 'Page {0}, Current Page',
      first: 'First page',
      last: 'Last page'
    }
  },
  rating: {
    ariaLabel: {
      item: 'Rating {0} of {1}'
    }
  }
});
;// CONCATENATED MODULE: ./src/composables/locale.ts


 // Types

const LocaleAdapterSymbol = Symbol.for('vuetify:locale-adapter');
const VuetifyLocaleSymbol = Symbol.for('vuetify:locale');
function provideLocale(props) {
  const adapter = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(LocaleAdapterSymbol);
  if (!adapter) throw new Error('[Vuetify] Could not find injected locale adapter');
  return adapter.createScope(props);
}
function useLocale() {
  const adapter = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(LocaleAdapterSymbol);
  if (!adapter) throw new Error('[Vuetify] Could not find injected locale adapter');
  return adapter.getScope();
}

function isLocaleAdapter(x) {
  return !!x && x.hasOwnProperty('getScope') && x.hasOwnProperty('createScope') && x.hasOwnProperty('createRoot');
}

function createLocaleAdapter(app, options) {
  const adapter = isLocaleAdapter(options) ? options : createDefaultLocaleAdapter(options);
  const rootInstance = adapter.createRoot(app);
  return {
    adapter,
    rootInstance
  };
}
const LANG_PREFIX = '$vuetify.';

const replace = (str, params) => {
  return str.replace(/\{(\d+)\}/g, (match, index) => {
    /* istanbul ignore next */
    return String(params[+index]);
  });
};

const createTranslateFunction = (current, fallback, messages) => {
  return (key, ...params) => {
    if (!key.startsWith(LANG_PREFIX)) {
      return replace(key, params);
    }

    const shortKey = key.replace(LANG_PREFIX, '');
    const currentLocale = current.value && messages.value[current.value];
    const fallbackLocale = fallback.value && messages.value[fallback.value];
    let str = getObjectValueByPath(currentLocale, shortKey, null);

    if (!str) {
      consoleWarn(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
      str = getObjectValueByPath(fallbackLocale, shortKey, null);
    }

    if (!str) {
      consoleError(`Translation key "${key}" not found in fallback`);
      str = key;
    }

    if (typeof str !== 'string') {
      consoleError(`Translation key "${key}" has a non-string value`);
      str = key;
    }

    return replace(str, params);
  };
};

function createNumberFunction(current, fallback) {
  return (value, options) => {
    const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
    return numberFormat.format(value);
  };
}

function createDefaultLocaleAdapter(options) {
  const createScope = options => {
    const current = wrapInRef(options.current);
    const fallback = wrapInRef(options.fallback);
    const messages = wrapInRef(options.messages);
    return {
      current,
      fallback,
      messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback)
    };
  };

  return {
    createRoot: app => {
      var _options$defaultLocal, _options$fallbackLoca, _options$messages;

      const rootScope = createScope({
        current: (_options$defaultLocal = options == null ? void 0 : options.defaultLocale) != null ? _options$defaultLocal : 'en',
        fallback: (_options$fallbackLoca = options == null ? void 0 : options.fallbackLocale) != null ? _options$fallbackLoca : 'en',
        messages: (_options$messages = options == null ? void 0 : options.messages) != null ? _options$messages : {
          en: en
        }
      });
      app.provide(VuetifyLocaleSymbol, rootScope);
      return rootScope;
    },
    getScope: () => {
      const currentScope = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(VuetifyLocaleSymbol);
      if (!currentScope) throw new Error('[Vuetify] Could not find injected locale instance');
      return currentScope;
    },
    createScope: options => {
      const currentScope = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(VuetifyLocaleSymbol);
      if (!currentScope) throw new Error('[Vuetify] Could not find injected locale instance');
      const newScope = createScope({
        current: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
          var _options$locale;

          return (_options$locale = options == null ? void 0 : options.locale) != null ? _options$locale : currentScope.current.value;
        }),
        fallback: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
          var _options$locale2;

          return (_options$locale2 = options == null ? void 0 : options.locale) != null ? _options$locale2 : currentScope.fallback.value;
        }),
        messages: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
          var _options$messages2;

          return (_options$messages2 = options == null ? void 0 : options.messages) != null ? _options$messages2 : currentScope.messages.value;
        })
      });
      (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.provide)(VuetifyLocaleSymbol, newScope);
      return newScope;
    }
  };
}
;// CONCATENATED MODULE: ./src/components/VLocaleProvider/VLocaleProvider.tsx

 // Composables


 // Utilities


/* harmony default export */ const VLocaleProvider = (defineComponent({
  name: 'VLocaleProvider',
  props: {
    locale: String,
    fallbackLocale: String,
    messages: Object,
    rtl: {
      type: Boolean,
      default: undefined
    }
  },

  setup(props, {
    slots
  }) {
    const localeInstance = provideLocale(props);
    const {
      rtlClasses
    } = provideRtl(props, localeInstance);
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": ['v-locale-provider', rtlClasses.value]
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 2);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VLocaleProvider/index.ts

;// CONCATENATED MODULE: ./src/components/VList/VList.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VList/VListSubheader.tsx

// Composables

 // Utilities



/* harmony default export */ const VListSubheader = (defineComponent({
  name: 'VListSubheader',
  props: {
    color: String,
    inset: Boolean,
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
      "class": ['v-list-subheader', {
        'v-list-subheader--inset': props.inset
      }, textColorClasses.value],
      "style": {
        textColorStyles
      }
    }, {
      default: () => [slots.default && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": "v-list-subheader__text"
      }, [slots.default()])]
    }, 8, ["class", "style"]);
  }

}));
;// CONCATENATED MODULE: ./src/components/VList/VList.tsx

// Styles
 // Components
// import { VListItem } from '.'

 // Composables








 // Utilities



/* harmony default export */ const VList = (defineComponent({
  name: 'VList',
  props: {
    color: String,
    disabled: Boolean,
    lines: {
      type: String,
      default: 'one'
    },
    nav: Boolean,
    subheader: {
      type: [Boolean, String],
      default: false
    },
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    const {
      borderClasses
    } = useBorder(props, 'v-list');
    const {
      densityClasses
    } = useDensity(props, 'v-list');
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, 'v-list');
    return () => {
      var _slots$default;

      const hasHeader = typeof props.subheader === 'string' || slots.subheader;
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-list', {
          'v-list--disabled': props.disabled,
          'v-list--nav': props.nav,
          'v-list--subheader': props.subheader,
          'v-list--subheader-sticky': props.subheader === 'sticky',
          [`v-list--${props.lines}-line`]: true
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, dimensionStyles.value]
      }, {
        default: () => [hasHeader && (slots.subheader ? slots.subheader() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VListSubheader, null, {
          default: () => [props.subheader]
        })), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VList/VListImg.ts

/* harmony default export */ const VListImg = (createSimpleFunctional('v-list-img'));
;// CONCATENATED MODULE: ./src/components/VList/VListItem.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VList/VListItemAvatar.tsx

// Composables
 // Utilities


/* harmony default export */ const VListItemAvatar = (defineComponent({
  name: 'VListItemAvatar',
  props: {
    left: Boolean,
    right: Boolean,
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-list-item-avatar', {
          'v-list-item-avatar--start': props.left,
          'v-list-item-avatar--end': props.right
        }]
      }, slots, 8, ["class"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VList/VListItemHeader.ts

/* harmony default export */ const VListItemHeader = (createSimpleFunctional('v-list-item-header'));
;// CONCATENATED MODULE: ./src/components/VList/VListItemSubtitle.ts

/* harmony default export */ const VListItemSubtitle = (createSimpleFunctional('v-list-item-subtitle'));
;// CONCATENATED MODULE: ./src/components/VList/VListItemTitle.ts

/* harmony default export */ const VListItemTitle = (createSimpleFunctional('v-list-item-title'));
;// CONCATENATED MODULE: ./src/components/VList/VListItem.tsx

// Styles
 // Components





 // Composables









 // Directives

 // Utilities



/* harmony default export */ const VListItem = (defineComponent({
  name: 'VListItem',
  directives: {
    Ripple: Ripple
  },
  props: {
    active: Boolean,
    activeColor: String,
    activeClass: String,
    appendAvatar: String,
    appendIcon: String,
    disabled: Boolean,
    link: Boolean,
    prependAvatar: String,
    prependIcon: String,
    subtitle: String,
    title: String,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: 'text'
    })
  },

  setup(props, {
    attrs,
    slots
  }) {
    var _props$activeColor;

    const link = useLink(props, attrs);
    const isActive = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _link$isExactActive;

      return props.active || ((_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value);
    });
    const activeColor = (_props$activeColor = props.activeColor) != null ? _props$activeColor : props.color;
    const variantProps = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.reactive)({
      color: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => isActive.value ? activeColor : props.color),
      textColor: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'textColor'),
      variant: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'variant')
    });
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-list-item');
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps, 'v-list-item');
    const {
      densityClasses
    } = useDensity(props, 'v-list-item');
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props, 'v-list-item');
    return () => {
      var _slots$default;

      const Tag = link.isLink.value ? 'a' : props.tag;
      const hasTitle = slots.title || props.title;
      const hasSubtitle = slots.subtitle || props.subtitle;
      const hasHeader = !!(hasTitle || hasSubtitle);
      const hasAppend = slots.append || props.appendAvatar || props.appendIcon;
      const hasPrepend = slots.prepend || props.prependAvatar || props.prependIcon;
      const isClickable = !props.disabled && (link.isClickable.value || props.link);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(Tag, {
        "class": ['v-list-item', {
          'v-list-item--active': isActive.value,
          'v-list-item--disabled': props.disabled,
          'v-list-item--link': isClickable,
          [`${props.activeClass}`]: isActive.value && props.activeClass
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value],
        "href": link.href.value,
        "tabindex": isClickable ? 0 : undefined,
        "onClick": isClickable && link.navigate
      }, {
        default: () => [genOverlays(!!(isClickable || isActive.value), 'v-list-item'), hasPrepend && (slots.prepend ? slots.prepend() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VListItemAvatar, {
          "left": true
        }, {
          default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VAvatar, {
            "density": props.density,
            "icon": props.prependIcon,
            "image": props.prependAvatar
          }, null, 8, ["density", "icon", "image"])]
        }, 8, ["left"])), hasHeader && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VListItemHeader, null, {
          default: () => [hasTitle && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VListItemTitle, null, {
            default: () => [slots.title ? slots.title() : props.title]
          }), hasSubtitle && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VListItemSubtitle, null, {
            default: () => [slots.subtitle ? slots.subtitle() : props.subtitle]
          })],
          _: 1
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), hasAppend && (slots.append ? slots.append() : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VListItemAvatar, {
          "right": true
        }, {
          default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VAvatar, {
            "density": props.density,
            "icon": props.appendIcon,
            "image": props.appendAvatar
          }, null, 8, ["density", "icon", "image"])]
        }, 8, ["right"]))],
        _: 1
      }, 8, ["class", "style", "href", "tabindex", "onClick"]), [[(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDirective)("ripple"), isClickable]]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VList/VListItemMedia.tsx

// Composables
 // Utilities


/* harmony default export */ const VListItemMedia = (defineComponent({
  name: 'VListItemMedia',
  props: {
    left: Boolean,
    right: Boolean,
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-list-item-media', {
          'v-list-item-media--start': props.left,
          'v-list-item-media--end': props.right
        }]
      }, slots, 8, ["class"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VList/index.ts









;// CONCATENATED MODULE: ./src/components/VLazy/VLazy.tsx

// Composables



 // Directives

 // Utilities


/* harmony default export */ const VLazy = (defineComponent({
  name: 'VLazy',
  directives: {
    intersect: intersect
  },
  props: {
    modelValue: Boolean,
    options: {
      type: Object,
      // For more information on types, navigate to:
      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
      default: () => ({
        root: undefined,
        rootMargin: undefined,
        threshold: undefined
      })
    },
    ...makeDimensionProps(),
    ...makeTagProps(),
    ...makeTransitionProps({
      transition: 'fade-transition'
    })
  },
  emits: {
    'update:modelValue': value => true
  },

  setup(props, {
    slots
  }) {
    const {
      dimensionStyles
    } = useDimension(props);
    const isActive = useProxiedModel(props, 'modelValue');

    function onIntersect(isIntersecting) {
      if (isActive.value) return;
      isActive.value = isIntersecting;
    }

    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": "v-lazy",
        "style": dimensionStyles.value
      }, {
        default: () => [isActive.value && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
        }, 8, ["transition"])]
      }, 8, ["style"]), [[(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDirective)("intersect"), onIntersect, props.options]]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VLazy/index.ts

;// CONCATENATED MODULE: ./src/components/VMain/VMain.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/composables/ssrBoot.ts
// Utilities
 // Composables

function useSsrBoot() {
  const isBooted = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(false);
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onMounted)(() => {
    window.requestAnimationFrame(() => {
      isBooted.value = true;
    });
  });
  const ssrBootStyles = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => !isBooted.value ? {
    transition: 'none !important'
  } : undefined);
  return {
    ssrBootStyles
  };
}
;// CONCATENATED MODULE: ./src/components/VMain/VMain.tsx

// Styles
 // Composables



 // Utilities


/* harmony default export */ const VMain = (defineComponent({
  name: 'VMain',
  props: makeTagProps({
    tag: 'main'
  }),

  setup(props, {
    slots
  }) {
    const {
      mainStyles
    } = useMain();
    const {
      ssrBootStyles
    } = useSsrBoot();
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": "v-main",
        "style": [mainStyles.value, ssrBootStyles.value]
      }, {
        default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-main__wrap"
        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)])]
      }, 8, ["style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VMain/index.ts

;// CONCATENATED MODULE: ./src/components/VNavigationDrawer/VNavigationDrawer.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VNavigationDrawer/VNavigationDrawer.tsx

// Styles
 // Composables









 // Utilities


 // Types

/* harmony default export */ const VNavigationDrawer = (defineComponent({
  name: 'VNavigationDrawer',
  props: {
    color: String,
    disableResizeWatcher: Boolean,
    expandOnHover: Boolean,
    floating: Boolean,
    modelValue: {
      type: Boolean,
      default: null
    },
    permanent: Boolean,
    rail: Boolean,
    railWidth: {
      type: [Number, String],
      default: 72
    },
    image: String,
    temporary: Boolean,
    width: {
      type: [Number, String],
      default: 256
    },
    position: {
      type: String,
      default: 'left',
      validator: value => ['left', 'right', 'bottom'].includes(value)
    },
    ...makeBorderProps(),
    ...makeElevationProps(),
    ...makeLayoutItemProps(),
    ...makeRoundedProps(),
    ...makeTagProps({
      tag: 'nav'
    }),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-navigation-drawer');
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    const {
      elevationClasses
    } = useElevation(props);
    const {
      mobile
    } = useDisplay();
    const {
      roundedClasses
    } = useRounded(props, 'v-navigation-drawer');
    const isActive = useProxiedModel(props, 'modelValue');
    const isHovering = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(false);
    const width = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      return props.rail && props.expandOnHover && isHovering.value ? props.width : Number(props.rail ? props.railWidth : props.width);
    });
    const isTemporary = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => !props.permanent && (mobile.value || props.temporary));
    const layoutStyles = useLayoutItem(props.name, (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'priority'), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'position'), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => isTemporary.value ? 0 : props.rail && props.expandOnHover ? Number(props.railWidth) : width.value), width, isActive);

    if (!props.disableResizeWatcher) {
      (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(mobile, val => !props.permanent && (isActive.value = !val));
    }

    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(props, val => {
      if (val.permanent) isActive.value = true;
    });
    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeMount)(() => {
      if (props.modelValue != null) return;
      isActive.value = props.permanent || !mobile.value;
    });
    return () => {
      var _slots$image, _slots$prepend, _slots$default, _slots$append;

      const hasImage = slots.image || props.image;
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "onMouseenter": () => isHovering.value = true,
        "onMouseleave": () => isHovering.value = false,
        "class": ['v-navigation-drawer', {
          'v-navigation-drawer--bottom': props.position === 'bottom',
          'v-navigation-drawer--end': props.position === 'right',
          'v-navigation-drawer--expand-on-hover': props.expandOnHover,
          'v-navigation-drawer--floating': props.floating,
          'v-navigation-drawer--is-hovering': isHovering.value,
          'v-navigation-drawer--rail': props.rail,
          'v-navigation-drawer--start': props.position === 'left',
          'v-navigation-drawer--temporary': isTemporary.value,
          'v-navigation-drawer--absolute': props.absolute
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, layoutStyles.value]
      }, {
        default: () => [hasImage && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-navigation-drawer__img"
        }, [slots.image ? (_slots$image = slots.image) == null ? void 0 : _slots$image.call(slots, {
          image: props.image
        }) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("img", {
          "src": props.image,
          "alt": ""
        }, null, 8, ["src"])]), slots.prepend && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-navigation-drawer__prepend"
        }, [(_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots)]), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-navigation-drawer__content"
        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), slots.append && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
          "class": "v-navigation-drawer__append"
        }, [(_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots)])],
        _: 1
      }, 8, ["onMouseenter", "onMouseleave", "class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VNavigationDrawer/index.ts

;// CONCATENATED MODULE: ./src/components/VOverlay/index.ts


;// CONCATENATED MODULE: ./src/components/VPagination/VPagination.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/composables/resizeObserver.ts
// Utilities

function useResizeObserver(callback) {
  const resizeRef = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
  const contentRect = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
  const contentBoxSize = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
  const borderBoxSize = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
  const observer = new ResizeObserver(entries => {
    callback == null ? void 0 : callback(entries, observer);
    if (!entries.length) return;
    contentRect.value = entries[0].contentRect;
    contentBoxSize.value = entries[0].contentBoxSize[0];
    borderBoxSize.value = entries[0].borderBoxSize[0];
  });
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeUnmount)(() => {
    observer.disconnect();
  });
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(resizeRef, (newValue, oldValue) => {
    if (oldValue) {
      observer.unobserve(oldValue);
      contentRect.value = undefined;
      contentBoxSize.value = undefined;
      borderBoxSize.value = undefined;
    }

    if (newValue) observer.observe(newValue);
  }, {
    flush: 'post'
  });
  return {
    resizeRef,
    contentRect: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.readonly)(contentRect),
    contentBoxSize: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.readonly)(contentBoxSize),
    borderBoxSize: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.readonly)(borderBoxSize)
  };
}
;// CONCATENATED MODULE: ./src/composables/refs.ts
// Imports

function useRefs() {
  const refs = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)([]);
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeUpdate)(() => refs.value = []);

  function updateRef(e, i) {
    refs.value[i] = e;
  }

  return {
    refs,
    updateRef
  };
}
;// CONCATENATED MODULE: ./src/components/VPagination/VPagination.tsx

 // Types

// Components
 // Utilities


 // Composables














/* harmony default export */ const VPagination = (defineComponent({
  name: 'VPagination',
  props: {
    start: {
      type: [Number, String],
      default: 1
    },
    modelValue: {
      type: Number,
      default: props => props.start
    },
    disabled: Boolean,
    length: {
      type: [Number, String],
      default: 1,
      validator: val => val % 1 === 0
    },
    totalVisible: [Number, String],
    firstIcon: {
      type: String,
      default: '$first'
    },
    prevIcon: {
      type: String,
      default: '$prev'
    },
    nextIcon: {
      type: String,
      default: '$next'
    },
    lastIcon: {
      type: String,
      default: '$last'
    },
    ariaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.root'
    },
    pageAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.page'
    },
    currentPageAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.currentPage'
    },
    firstAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.first'
    },
    previousAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.previous'
    },
    nextAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.next'
    },
    lastAriaLabel: {
      type: String,
      default: '$vuetify.pagination.ariaLabel.last'
    },
    ellipsis: {
      type: String,
      default: '...'
    },
    showFirstLastPage: Boolean,
    ...makeTagProps({
      tag: 'nav'
    }),
    ...makeElevationProps(),
    ...makeDensityProps(),
    ...makeRoundedProps(),
    ...makeSizeProps(),
    ...makeBorderProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: 'text'
    })
  },
  emits: {
    'update:modelValue': value => true,
    first: value => true,
    prev: value => true,
    next: value => true,
    last: value => true
  },

  setup(props, {
    slots,
    emit
  }) {
    const page = useProxiedModel(props, 'modelValue');
    const {
      t,
      n
    } = useLocale();
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = useTheme(props);
    const maxButtons = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(-1);
    const {
      resizeRef
    } = useResizeObserver(entries => {
      if (!entries.length) return;
      const {
        target,
        contentRect
      } = entries[0];
      const firstItem = target.querySelector('.v-pagination__list > *');
      if (!firstItem) return;
      const totalWidth = contentRect.width;
      const itemWidth = firstItem.getBoundingClientRect().width + 10;
      maxButtons.value = Math.max(0, Math.floor((totalWidth - 96) / itemWidth));
    });
    const length = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => parseInt(props.length, 10));
    const start = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => parseInt(props.start, 10));
    const totalVisible = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _props$totalVisible;

      if (props.totalVisible) return Math.min(parseInt((_props$totalVisible = props.totalVisible) != null ? _props$totalVisible : '', 10), length.value);else if (maxButtons.value >= 0) return maxButtons.value;
      return length.value;
    });
    const range = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      if (length.value <= 0) return [];

      if (totalVisible.value <= 3) {
        return [Math.min(Math.max(start.value, page.value), start.value + length.value)];
      }

      if (props.length <= totalVisible.value) {
        return createRange(length.value, start.value);
      }

      const middle = Math.ceil(totalVisible.value / 2);
      const left = middle;
      const right = length.value - middle;

      if (page.value < left) {
        return [...createRange(Math.max(1, totalVisible.value - 2), start.value), props.ellipsis, length.value];
      } else if (page.value > right) {
        const rangeLength = totalVisible.value - 2;
        const rangeStart = length.value - rangeLength + start.value;
        return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart)];
      } else {
        const rangeLength = Math.max(1, totalVisible.value - 4);
        const rangeStart = rangeLength === 1 ? page.value : page.value - Math.ceil(rangeLength / 2) + start.value;
        return [start.value, props.ellipsis, ...createRange(rangeLength, rangeStart), props.ellipsis, length.value];
      }
    }); // TODO: 'first' | 'prev' | 'next' | 'last' does not work here?

    function setValue(e, value, event) {
      e.preventDefault();
      page.value = value;
      event && emit(event, value);
    }

    const {
      refs,
      updateRef
    } = useRefs();
    const items = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      const sharedProps = {
        density: props.density,
        rounded: props.rounded,
        size: props.size
      };
      return range.value.map((item, index) => {
        const ref = e => updateRef(e, index);

        if (typeof item === 'string') {
          return {
            isActive: false,
            page: item,
            props: { ...sharedProps,
              ref,
              ellipsis: true,
              icon: true,
              disabled: true,
              variant: props.variant,
              border: props.border
            }
          };
        } else {
          const isActive = item === page.value;
          return {
            isActive,
            page: n(item),
            props: { ...sharedProps,
              ref,
              ellipsis: false,
              icon: true,
              disabled: !!props.disabled || props.length < 2,
              elevation: props.elevation,
              variant: props.variant,
              border: props.border,
              color: isActive ? props.color : undefined,
              ariaCurrent: isActive,
              ariaLabel: t(isActive ? props.currentPageAriaLabel : props.pageAriaLabel, index + 1),
              onClick: e => setValue(e, item)
            }
          };
        }
      });
    });
    const controls = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      const sharedProps = {
        color: undefined,
        density: props.density,
        rounded: props.rounded,
        size: props.size,
        variant: props.variant,
        border: props.border
      };
      const prevDisabled = !!props.disabled || page.value <= start.value;
      const nextDisabled = !!props.disabled || page.value >= start.value + length.value - 1;
      return {
        first: props.showFirstLastPage ? { ...sharedProps,
          icon: isRtl.value ? props.lastIcon : props.firstIcon,
          onClick: e => setValue(e, start.value, 'first'),
          disabled: prevDisabled,
          ariaLabel: t(props.firstAriaLabel),
          ariaDisabled: prevDisabled
        } : undefined,
        prev: { ...sharedProps,
          icon: isRtl.value ? props.nextIcon : props.prevIcon,
          onClick: e => setValue(e, page.value - 1, 'prev'),
          disabled: prevDisabled,
          ariaLabel: t(props.previousAriaLabel),
          ariaDisabled: prevDisabled
        },
        next: { ...sharedProps,
          icon: isRtl.value ? props.prevIcon : props.nextIcon,
          onClick: e => setValue(e, page.value + 1, 'next'),
          disabled: nextDisabled,
          ariaLabel: t(props.nextAriaLabel),
          ariaDisabled: nextDisabled
        },
        last: props.showFirstLastPage ? { ...sharedProps,
          icon: isRtl.value ? props.firstIcon : props.lastIcon,
          onClick: e => setValue(e, start.value + length.value - 1, 'last'),
          disabled: nextDisabled,
          ariaLabel: t(props.lastAriaLabel),
          ariaDisabled: nextDisabled
        } : undefined
      };
    });

    function updateFocus() {
      var _refs$value$currentIn;

      const currentIndex = page.value - start.value;
      (_refs$value$currentIn = refs.value[currentIndex]) == null ? void 0 : _refs$value$currentIn.$el.focus();
    }

    function onKeydown(e) {
      if (e.key === keyValues.left && !props.disabled && page.value > props.start) {
        page.value = page.value - 1;
        (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.nextTick)(updateFocus);
      } else if (e.key === keyValues.right && !props.disabled && page.value < start.value + length.value - 1) {
        page.value = page.value + 1;
        (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.nextTick)(updateFocus);
      }
    }

    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
      "ref": resizeRef,
      "class": ['v-pagination', themeClasses.value],
      "role": "navigation",
      "aria-label": t(props.ariaLabel),
      "onKeydown": onKeydown,
      "data-test": "v-pagination-root"
    }, {
      default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("ul", {
        "class": "v-pagination__list"
      }, [props.showFirstLastPage && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("li", {
        "class": "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [slots.first ? slots.first(controls.value.first) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBtn, controls.value.first, null, 16)]), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("li", {
        "class": "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [slots.prev ? slots.prev(controls.value.prev) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBtn, controls.value.prev, null, 16)]), items.value.map((item, index) => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("li", {
        "key": `${index}_${item.page}`,
        "class": ['v-pagination__item', {
          'v-pagination__item--is-active': item.isActive
        }],
        "data-test": "v-pagination-item"
      }, [slots.item ? slots.item(item) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBtn, item.props, {
        default: () => [item.page]
      }, 16)], 2)), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("li", {
        "class": "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [slots.next ? slots.next(controls.value.next) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBtn, controls.value.next, null, 16)]), props.showFirstLastPage && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("li", {
        "class": "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [slots.last ? slots.last(controls.value.last) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBtn, controls.value.last, null, 16)])])]
    }, 8, ["class", "aria-label", "onKeydown"]);
  }

}));
;// CONCATENATED MODULE: ./src/components/VPagination/index.ts

;// CONCATENATED MODULE: ./src/components/VSheet/VSheet.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VSheet/VSheet.tsx

// Styles
 // Composables








 // Utilities



/* harmony default export */ const VSheet = (defineComponent({
  name: 'VSheet',
  props: {
    color: {
      type: String,
      default: 'surface'
    },
    ...makeBorderProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    const {
      borderClasses
    } = useBorder(props, 'v-sheet');
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, 'v-sheet');
    const {
      roundedClasses
    } = useRounded(props, 'v-sheet');
    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
      "class": ['v-sheet', themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value],
      "style": [backgroundColorStyles.value, dimensionStyles.value, positionStyles.value]
    }, slots, 8, ["class", "style"]);
  }

}));
;// CONCATENATED MODULE: ./src/components/VSheet/index.ts

;// CONCATENATED MODULE: ./src/components/VProgressCircular/VProgressCircular.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/composables/intersectionObserver.ts
// Utilities

function useIntersectionObserver(callback) {
  const intersectionRef = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
  const isIntersecting = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(false);
  const observer = new IntersectionObserver(entries => {
    callback == null ? void 0 : callback(entries, observer);
    isIntersecting.value = !!entries.find(entry => entry.isIntersecting);
  });
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.onBeforeUnmount)(() => {
    observer.disconnect();
  });
  (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(intersectionRef, (newValue, oldValue) => {
    if (oldValue) {
      observer.unobserve(oldValue);
      isIntersecting.value = false;
    }

    if (newValue) observer.observe(newValue);
  }, {
    flush: 'post'
  });
  return {
    intersectionRef,
    isIntersecting
  };
}
;// CONCATENATED MODULE: ./src/components/VProgressCircular/VProgressCircular.tsx

// Styles
 // Composables





 // Utilities


 // Types

/* harmony default export */ const VProgressCircular = (defineComponent({
  name: 'VProgressCircular',
  props: {
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
      type: [Number, String],
      default: 0
    },
    rotate: {
      type: [Number, String],
      default: 0
    },
    width: {
      type: [Number, String],
      default: 4
    },
    ...makeSizeProps(),
    ...makeTagProps({
      tag: 'div'
    }),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const MAGIC_RADIUS_CONSTANT = 20;
    const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
    const {
      themeClasses
    } = useTheme(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props, 'v-progress-circular');
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'color'));
    const {
      textColorClasses: underlayColorClasses,
      textColorStyles: underlayColorStyles
    } = useTextColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'bgColor'));
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const normalizedValue = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => Math.max(0, Math.min(100, parseFloat(props.modelValue))));
    const width = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => Number(props.width));
    const size = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      // Get size from element if size prop value is small, large etc
      return sizeStyles.value ? Number(props.size) : intersectionRef.value ? intersectionRef.value.getBoundingClientRect().width : Math.max(width.value, 32);
    });
    const diameter = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size.value) * 2);
    const strokeWidth = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => width.value / size.value * diameter.value);
    const strokeDashOffset = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
      "ref": intersectionRef,
      "class": ['v-progress-circular', {
        'v-progress-circular--indeterminate': !!props.indeterminate,
        'v-progress-circular--visible': isIntersecting.value,
        'v-progress-circular--disable-shrink': props.indeterminate === 'disable-shrink'
      }, themeClasses.value, sizeClasses.value, textColorClasses.value],
      "style": [sizeStyles.value, textColorStyles.value],
      "role": "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": props.indeterminate ? undefined : normalizedValue.value
    }, {
      default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("svg", {
        "style": {
          transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
        },
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": `0 0 ${diameter.value} ${diameter.value}`
      }, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("circle", {
        "class": ['v-progress-circular__underlay', underlayColorClasses.value],
        "style": underlayColorStyles.value,
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": 0
      }, null, 14, ["r", "stroke-width", "stroke-dasharray"]), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("circle", {
        "class": "v-progress-circular__overlay",
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": strokeDashOffset.value
      }, null, 8, ["r", "stroke-width", "stroke-dasharray", "stroke-dashoffset"])]), slots.default && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": "v-progress-circular__content"
      }, [slots.default({
        value: normalizedValue.value
      })])],
      _: 1
    }, 8, ["class", "style", "aria-valuenow"]);
  }

}));
;// CONCATENATED MODULE: ./src/components/VProgressCircular/index.ts

;// CONCATENATED MODULE: ./src/components/VRating/VRating.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VRating/VRating.tsx

// Styles
 // Components

 // Composables






 // Utilities


 // Types

/* harmony default export */ const VRating = (defineComponent({
  name: 'VRating',
  props: {
    name: String,
    itemAriaLabel: {
      type: String,
      default: '$vuetify.rating.ariaLabel.item'
    },
    activeColor: String,
    color: String,
    clearable: Boolean,
    disabled: Boolean,
    emptyIcon: {
      type: String,
      default: '$ratingEmpty'
    },
    fullIcon: {
      type: String,
      default: '$ratingFull'
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
      type: [Number, String],
      default: 5
    },
    readonly: Boolean,
    modelValue: {
      type: Number,
      default: 0
    },
    itemLabels: Array,
    itemLabelPosition: {
      type: String,
      default: 'top',
      validator: v => ['top', 'bottom'].includes(v)
    },
    ripple: Boolean,
    ...makeDensityProps(),
    ...makeSizeProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  emits: {
    'update:modelValue': value => true
  },

  setup(props, {
    slots
  }) {
    const {
      t
    } = useLocale();
    const {
      themeClasses
    } = useTheme(props);
    const rating = useProxiedModel(props, 'modelValue');
    const range = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => createRange(Number(props.length), 1));
    const increments = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => range.value.flatMap(v => props.halfIncrements ? [v - 0.5, v] : [v]));
    const hoverIndex = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(-1);
    const focusIndex = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(-1);
    const firstRef = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
    let isClicking = false;
    const itemState = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => increments.value.map(value => {
      var _props$activeColor;

      const isHovering = props.hover && hoverIndex.value > -1;
      const isFilled = rating.value >= value;
      const isHovered = hoverIndex.value >= value;
      const isFullIcon = isHovering ? isHovered : isFilled;
      const icon = isFullIcon ? props.fullIcon : props.emptyIcon;
      const activeColor = (_props$activeColor = props.activeColor) != null ? _props$activeColor : props.color;
      const color = isFilled || isHovered ? activeColor : props.color;
      return {
        isFilled,
        isHovered,
        icon,
        color
      };
    }));
    const eventState = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => [0, ...increments.value].map(value => {
      function onMouseenter() {
        hoverIndex.value = value;
      }

      function onMouseleave() {
        hoverIndex.value = -1;
      }

      function onFocus() {
        if (value === 0 && rating.value === 0) {
          var _firstRef$value;

          (_firstRef$value = firstRef.value) == null ? void 0 : _firstRef$value.focus();
        } else {
          focusIndex.value = value;
        }
      }

      function onBlur() {
        if (!isClicking) focusIndex.value = -1;
      }

      function onClick() {
        if (props.disabled || props.readonly) return;
        rating.value = rating.value === value && props.clearable ? 0 : value;
      }

      return {
        onMouseenter: props.hover ? onMouseenter : undefined,
        onMouseleave: props.hover ? onMouseleave : undefined,
        onFocus,
        onBlur,
        onClick
      };
    }));

    function onMousedown() {
      isClicking = true;
    }

    function onMouseup() {
      isClicking = false;
    }

    const name = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      var _props$name;

      return (_props$name = props.name) != null ? _props$name : `v-rating-${getUid()}`;
    });

    function VRatingItem({
      value,
      index,
      showStar = true
    }) {
      var _itemState$value$inde, _itemState$value$inde2;

      const {
        onMouseenter,
        onMouseleave,
        onFocus,
        onBlur,
        onClick
      } = eventState.value[index + 1];
      const id = `${name.value}-${String(value).replace('.', '-')}`;
      const btnProps = {
        color: (_itemState$value$inde = itemState.value[index]) == null ? void 0 : _itemState$value$inde.color,
        density: props.density,
        disabled: props.disabled,
        icon: (_itemState$value$inde2 = itemState.value[index]) == null ? void 0 : _itemState$value$inde2.icon,
        ripple: props.ripple,
        size: props.size,
        tag: 'span',
        variant: 'plain'
      };
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Fragment, null, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("label", {
        "for": id,
        "class": {
          'v-rating__item--half': props.halfIncrements && value % 1 > 0,
          'v-rating__item--full': props.halfIncrements && value % 1 === 0
        },
        "onMousedown": onMousedown,
        "onMouseup": onMouseup,
        "onMouseenter": onMouseenter,
        "onMouseleave": onMouseleave
      }, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("span", {
        "class": "v-rating__hidden"
      }, [t(props.itemAriaLabel, value, props.length)]), !showStar ? undefined : slots.item ? slots.item({ ...itemState.value,
        props: btnProps,
        value,
        index
      }) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VBtn, btnProps, null, 16)], 42, ["for", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave"]), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("input", {
        "class": "v-rating__hidden",
        "name": name.value,
        "id": id,
        "type": "radio",
        "value": value,
        "checked": rating.value === value,
        "onClick": onClick,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "ref": index === 0 ? firstRef : undefined,
        "readonly": props.readonly,
        "disabled": props.disabled
      }, null, 40, ["name", "id", "value", "checked", "onClick", "onFocus", "onBlur", "readonly", "disabled"])]);
    }

    return () => {
      var _props$itemLabels;

      const hasLabels = !!((_props$itemLabels = props.itemLabels) != null && _props$itemLabels.length);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-rating', {
          'v-rating--readonly': props.readonly
        }, themeClasses.value]
      }, {
        default: () => [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VRatingItem, {
          "value": 0,
          "index": -1,
          "showStar": false
        }, null, 8, ["index"]), range.value.map((value, i) => {
          var _props$itemLabels2, _props$itemLabels3;

          return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
            "class": "v-rating__wrapper"
          }, [!hasLabels ? undefined : slots['item-label'] ? slots['item-label']() : (_props$itemLabels2 = props.itemLabels) != null && _props$itemLabels2[i] ? (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("span", null, [(_props$itemLabels3 = props.itemLabels) == null ? void 0 : _props$itemLabels3[i]]) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("span", null, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createTextVNode)("\xA0")]), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
            "class": ['v-rating__item', {
              'v-rating__item--focused': Math.ceil(focusIndex.value) === value
            }]
          }, [props.halfIncrements ? (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Fragment, null, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VRatingItem, {
            "value": value - 0.5,
            "index": i * 2
          }, null, 8, ["value", "index"]), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VRatingItem, {
            "value": value,
            "index": i * 2 + 1
          }, null, 8, ["value", "index"])]) : (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VRatingItem, {
            "value": value,
            "index": i
          }, null, 8, ["value", "index"])], 2)]);
        })],
        _: 1
      }, 8, ["class"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VRating/index.ts

;// CONCATENATED MODULE: ./src/components/VResponsive/index.ts

;// CONCATENATED MODULE: ./src/components/VSystemBar/VSystemBar.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VSystemBar/VSystemBar.tsx

// Styles
 // Composables







 // Utilities


/* harmony default export */ const VSystemBar = (defineComponent({
  name: 'VSystemBar',
  props: {
    lightsOut: Boolean,
    window: Boolean,
    ...makeBorderProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      borderClasses
    } = useBorder(props, 'v-system-bar');
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props, 'v-system-bar');
    const {
      roundedClasses
    } = useRounded(props, 'v-system-bar');
    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
      "class": [{
        'v-system-bar': true,
        'v-system-bar--lights-out': props.lightsOut,
        'v-system-bar--window': props.window
      }, themeClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value],
      "style": [dimensionStyles.value, positionStyles.value]
    }, slots, 8, ["class", "style"]);
  }

}));
;// CONCATENATED MODULE: ./src/components/VSystemBar/index.ts

;// CONCATENATED MODULE: ./src/components/VThemeProvider/VThemeProvider.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VThemeProvider/VThemeProvider.tsx

// Styles
 // Composables


 // Utilities


/* harmony default export */ const VThemeProvider = (defineComponent({
  name: 'VThemeProvider',
  props: {
    withBackground: Boolean,
    ...makeThemeProps(),
    ...makeTagProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    return () => {
      var _slots$default, _slots$default2;

      if (!props.withBackground) return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-theme-provider', themeClasses.value]
      }, {
        default: () => [(_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)]
      }, 8, ["class"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VThemeProvider/index.ts

;// CONCATENATED MODULE: ./src/components/VTimeline/VTimeline.sass
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/components/VTimeline/VTimelineDivider.tsx

// Components

 // Composables




 // Utilities


/* harmony default export */ const VTimelineDivider = ((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.defineComponent)({
  name: 'VTimelineDivider',
  props: {
    hideDot: Boolean,
    lineColor: String,
    icon: String,
    iconColor: String,
    fillDot: Boolean,
    dotColor: String,
    ...makeRoundedProps(),
    ...makeSizeProps(),
    ...makeElevationProps()
  },

  setup(props, {
    slots
  }) {
    const timeline = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(VTimelineSymbol);
    if (!timeline) throw new Error('[Vuetify] Could not find v-timeline provider');
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props, 'v-timeline-divider__dot');
    const {
      backgroundColorStyles,
      backgroundColorClasses
    } = useBackgroundColor((0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'dotColor'));
    const {
      backgroundColorStyles: lineColorStyles,
      backgroundColorClasses: lineColorClasses
    } = useBackgroundColor(timeline.lineColor);
    const {
      roundedClasses
    } = useRounded(props, 'v-timeline-divider__dot');
    const {
      elevationClasses
    } = useElevation(props);
    return () => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
      "class": ['v-timeline-divider', {
        'v-timeline-divider--fill-dot': props.fillDot
      }]
    }, [!props.hideDot && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
      "class": ['v-timeline-divider__dot', roundedClasses.value, sizeClasses.value, elevationClasses.value],
      "style": sizeStyles.value
    }, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
      "class": ['v-timeline-divider__inner-dot', roundedClasses.value, backgroundColorClasses.value],
      "style": backgroundColorStyles.value
    }, [slots.default ? slots.default({
      icon: props.icon,
      iconColor: props.iconColor,
      size: props.size
    }) : props.icon ? (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VIcon, {
      "icon": props.icon,
      "color": props.iconColor,
      "size": props.size
    }, null, 8, ["icon", "color", "size"]) : undefined], 6)], 6), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
      "class": ['v-timeline-divider__line', lineColorClasses.value],
      "style": lineColorStyles.value
    }, null, 6)], 2);
  }

}));
;// CONCATENATED MODULE: ./src/components/VTimeline/VTimelineItem.tsx

// Types
// Components

 // Composables




 // Utilities




/* harmony default export */ const VTimelineItem = (defineComponent({
  name: 'VTimelineItem',
  props: {
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    hideOpposite: {
      type: Boolean,
      default: undefined
    },
    icon: String,
    iconColor: String,
    ...makeRoundedProps(),
    ...makeElevationProps(),
    ...makeSizeProps(),
    ...makeTagProps(),
    ...makeDimensionProps()
  },

  setup(props, {
    slots
  }) {
    const timeline = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.inject)(VTimelineSymbol);
    if (!timeline) throw new Error('[Vuetify] Could not find v-timeline provider');
    const {
      dimensionStyles
    } = useDimension(props);
    const dotSize = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)(0);
    const dotRef = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.ref)();
    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.watch)(dotRef, newValue => {
      var _newValue$$el$querySe, _newValue$$el$querySe2;

      if (!newValue) return;
      dotSize.value = (_newValue$$el$querySe = (_newValue$$el$querySe2 = newValue.$el.querySelector('.v-timeline-divider__dot')) == null ? void 0 : _newValue$$el$querySe2.getBoundingClientRect().width) != null ? _newValue$$el$querySe : 0;
    }, {
      flush: 'post'
    });
    return () => {
      var _slots$default, _slots$opposite;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": ['v-timeline-item', {
          'v-timeline-item--fill-dot': props.fillDot
        }],
        "style": {
          // @ts-expect-error: broken vue types
          '--v-timeline-dot-size': convertToUnit(dotSize.value)
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": "v-timeline-item__body",
        "style": dimensionStyles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)], 4), (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VTimelineDivider, {
        "ref": dotRef,
        "hideDot": props.hideDot,
        "icon": props.icon,
        "iconColor": props.iconColor,
        "size": props.size,
        "elevation": props.elevation,
        "dotColor": props.dotColor,
        "fillDot": props.fillDot,
        "rounded": props.rounded
      }, {
        default: slots.icon
      }, 8, ["hideDot", "icon", "iconColor", "size", "elevation", "dotColor", "fillDot", "rounded"]), timeline.density.value !== 'compact' && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)("div", {
        "class": "v-timeline-item__opposite"
      }, [!props.hideOpposite && ((_slots$opposite = slots.opposite) == null ? void 0 : _slots$opposite.call(slots))])], 6);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VTimeline/VTimeline.tsx

// Styles
 // Components

 // Composables



 // Helpers


 // Types

const VTimelineSymbol = Symbol.for('vuetify:timeline');
/* harmony default export */ const VTimeline = (defineComponent({
  name: 'VTimeline',
  props: {
    direction: {
      type: String,
      default: 'vertical',
      validator: v => ['vertical', 'horizontal'].includes(v)
    },
    side: {
      type: String,
      validator: v => v == null || ['start', 'end'].includes(v)
    },
    lineInset: {
      type: [String, Number],
      default: 0
    },
    lineThickness: {
      type: [String, Number],
      default: 2
    },
    lineColor: String,
    truncateLine: {
      type: String,
      default: 'start',
      validator: v => ['none', 'start', 'end', 'both'].includes(v)
    },
    ...makeDensityProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },

  setup(props, {
    slots
  }) {
    const {
      themeClasses
    } = useTheme(props);
    const {
      densityClasses
    } = useDensity(props, 'v-timeline');
    (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.provide)(VTimelineSymbol, {
      density: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'density'),
      lineColor: (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.toRef)(props, 'lineColor')
    });
    const sideClass = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.computed)(() => {
      const side = props.side ? props.side : props.density !== 'default' ? 'end' : null;
      return side && `v-timeline--side-${side}`;
    });
    return () => {
      var _slots$default;

      return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(props.tag, {
        "class": ['v-timeline', `v-timeline--${props.direction}`, {
          'v-timeline--inset-line': !!props.lineInset,
          'v-timeline--truncate-line-end': props.truncateLine === 'end' || props.truncateLine === 'both'
        }, themeClasses.value, densityClasses.value, sideClass.value],
        "style": {
          '--v-timeline-line-thickness': convertToUnit(props.lineThickness),
          '--v-timeline-line-inset': convertToUnit(props.lineInset || undefined)
        }
      }, {
        default: () => [(props.truncateLine === 'none' || props.truncateLine === 'end') && (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createVNode)(VTimelineItem, {
          "hideDot": true
        }, null, 8, ["hideDot"]), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)],
        _: 1
      }, 8, ["class", "style"]);
    };
  }

}));
;// CONCATENATED MODULE: ./src/components/VTimeline/index.ts


;// CONCATENATED MODULE: ./src/components/transitions/createTransition.ts
// Utilities

 // Types

function createCssTransition(name, origin = 'top center 0', mode) {
  return defineComponent({
    name,
    props: {
      group: Boolean,
      hideOnLeave: Boolean,
      leaveAbsolute: Boolean,
      mode: {
        type: String,
        default: mode
      },
      origin: {
        type: String,
        default: origin
      }
    },

    setup(props, {
      slots
    }) {
      return () => {
        const tag = props.group ? external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.TransitionGroup : external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Transition;
        return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(tag, {
          name,
          mode: props.mode,

          onBeforeEnter(el) {
            el.style.transformOrigin = props.origin;
          },

          onLeave(el) {
            if (props.leaveAbsolute) {
              const {
                offsetTop,
                offsetLeft,
                offsetWidth,
                offsetHeight
              } = el;
              el._transitionInitialStyles = {
                position: el.style.position,
                top: el.style.top,
                left: el.style.left,
                width: el.style.width,
                height: el.style.height
              };
              el.style.position = 'absolute';
              el.style.top = `${offsetTop}px`;
              el.style.left = `${offsetLeft}px`;
              el.style.width = `${offsetWidth}px`;
              el.style.height = `${offsetHeight}px`;
            }

            if (props.hideOnLeave) {
              el._initialDisplay = el.style.display;
              el.style.display = 'none';
            }
          },

          onAfterLeave(el) {
            if (props.leaveAbsolute && el != null && el._transitionInitialStyles) {
              const {
                position,
                top,
                left,
                width,
                height
              } = el._transitionInitialStyles;
              delete el._transitionInitialStyles;
              el.style.position = position || '';
              el.style.top = top || '';
              el.style.left = left || '';
              el.style.width = width || '';
              el.style.height = height || '';
            }

            if (props.hideOnLeave && el) {
              el.style.display = el._initialDisplay || '';
            }
          }

        }, slots.default);
      };
    }

  });
}
function createJavascriptTransition(name, functions, mode = 'in-out') {
  return defineComponent({
    name,
    props: {
      mode: {
        type: String,
        default: mode
      }
    },

    setup(props, {
      slots
    }) {
      return () => {
        return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Transition, {
          name,
          // mode: props.mode, // TODO: vuejs/vue-next#3104
          ...functions
        }, slots.default);
      };
    }

  });
}
;// CONCATENATED MODULE: ./src/components/transitions/expand-transition.ts
// Utilities

/* harmony default export */ function expand_transition(expandedParentClass = '', x = false) {
  const sizeProperty = x ? 'width' : 'height';
  const offsetProperty = (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.camelize)(`offset-${sizeProperty}`);
  return {
    onBeforeEnter(el) {
      el._parent = el.parentNode;
      el._initialStyle = {
        transition: el.style.transition,
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
    },

    onEnter(el) {
      const initialStyle = el._initialStyle;
      el.style.setProperty('transition', 'none', 'important'); // Hide overflow to account for collapsed margins in the calculated height

      el.style.overflow = 'hidden';
      const offset = `${el[offsetProperty]}px`;
      el.style[sizeProperty] = '0';
      void el.offsetHeight; // force reflow

      el.style.transition = initialStyle.transition;

      if (expandedParentClass && el._parent) {
        el._parent.classList.add(expandedParentClass);
      }

      requestAnimationFrame(() => {
        el.style[sizeProperty] = offset;
      });
    },

    onAfterEnter: resetStyles,
    onEnterCancelled: resetStyles,

    onLeave(el) {
      el._initialStyle = {
        transition: '',
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
      el.style.overflow = 'hidden';
      el.style[sizeProperty] = `${el[offsetProperty]}px`;
      void el.offsetHeight; // force reflow

      requestAnimationFrame(() => el.style[sizeProperty] = '0');
    },

    onAfterLeave,
    onLeaveCancelled: onAfterLeave
  };

  function onAfterLeave(el) {
    if (expandedParentClass && el._parent) {
      el._parent.classList.remove(expandedParentClass);
    }

    resetStyles(el);
  }

  function resetStyles(el) {
    const size = el._initialStyle[sizeProperty];
    el.style.overflow = el._initialStyle.overflow;
    if (size != null) el.style[sizeProperty] = size;
    delete el._initialStyle;
  }
}
;// CONCATENATED MODULE: ./src/components/transitions/index.ts

 // Component specific transitions

const VCarouselTransition = createCssTransition('carousel-transition');
const VCarouselReverseTransition = createCssTransition('carousel-reverse-transition');
const VTabTransition = createCssTransition('tab-transition');
const VTabReverseTransition = createCssTransition('tab-reverse-transition');
const VMenuTransition = createCssTransition('menu-transition');
const VFabTransition = createCssTransition('fab-transition', 'center center', 'out-in'); // Generic transitions

const VDialogBottomTransition = createCssTransition('dialog-bottom-transition');
const VDialogTopTransition = createCssTransition('dialog-top-transition');
const VFadeTransition = createCssTransition('fade-transition');
const VScaleTransition = createCssTransition('scale-transition');
const VScrollXTransition = createCssTransition('scroll-x-transition');
const VScrollXReverseTransition = createCssTransition('scroll-x-reverse-transition');
const VScrollYTransition = createCssTransition('scroll-y-transition');
const VScrollYReverseTransition = createCssTransition('scroll-y-reverse-transition');
const VSlideXTransition = createCssTransition('slide-x-transition');
const VSlideXReverseTransition = createCssTransition('slide-x-reverse-transition');
const VSlideYTransition = createCssTransition('slide-y-transition');
const VSlideYReverseTransition = createCssTransition('slide-y-reverse-transition'); // Javascript transitions

const VExpandTransition = createJavascriptTransition('expand-transition', expand_transition());
const VExpandXTransition = createJavascriptTransition('expand-x-transition', expand_transition('', true));

;// CONCATENATED MODULE: ./src/components/index.ts


 // export * from './VAutocomplete'




 // export * from './VBottomSheet'

 // export * from './VBtn'

 // export * from './VBtnToggle'
// export * from './VCalendar'

 // export * from './VCarousel'
// export * from './VCheckbox'

 // export * from './VChipGroup'

 // export * from './VColorPicker'
// export * from './VContent'
// export * from './VCombobox'
// export * from './VCounter'
// export * from './VData'
// export * from './VDataIterator'
// export * from './VDataTable'
// export * from './VDatePicker'



 // export * from './VExpansionPanel'
// export * from './VFileInput'

 // export * from './VForm'

 // export * from './VHover'


 // export * from './VInput'
// export * from './VItemGroup'


 // export * from './VLabel'





 // export * from './VMenu'
// export * from './VMessages'

 // export * from './VOverflowBtn'



 // export * from './VParallax'
// export * from './VPicker'

 // export * from './VProgressLinear'
// export * from './VRadioGroup'
// export * from './VRangeSlider'


 // export * from './VSelect'
// export * from './VSkeletonLoader'
// export * from './VSlider'
// export * from './VSlideGroup'
// export * from './VSnackbar'
// export * from './VSparkline'
// export * from './VSpeedDial'
// export * from './VStepper'
// export * from './VSwitch'

 // export * from './VTabs'
// export * from './VTextarea'
// export * from './VTextField'


 // export * from './VTimePicker'
// export * from './VToolbar'
// export * from './VTooltip'
// export * from './VTreeview'
// export * from './VVirtualScroll'
// export * from './VWindow'


;// CONCATENATED MODULE: ./src/directives/resize/index.ts
function resize_mounted(el, binding) {
  var _binding$modifiers, _binding$modifiers2;

  const handler = binding.value;
  const options = {
    passive: !((_binding$modifiers = binding.modifiers) != null && _binding$modifiers.active)
  };
  window.addEventListener('resize', handler, options);
  el._onResize = {
    handler,
    options
  };

  if (!((_binding$modifiers2 = binding.modifiers) != null && _binding$modifiers2.quiet)) {
    handler();
  }
}

function resize_unmounted(el) {
  if (!el._onResize) return;
  const {
    handler,
    options
  } = el._onResize;
  window.removeEventListener('resize', handler, options);
  delete el._onResize;
}

const Resize = {
  mounted: resize_mounted,
  unmounted: resize_unmounted
};
/* harmony default export */ const resize = ((/* unused pure expression or super */ null && (Resize)));
;// CONCATENATED MODULE: ./src/directives/scroll/index.ts
function scroll_mounted(el, binding) {
  var _binding$modifiers;

  const {
    self = false
  } = (_binding$modifiers = binding.modifiers) != null ? _binding$modifiers : {};
  const value = binding.value;
  const options = typeof value === 'object' && value.options || {
    passive: true
  };
  const handler = typeof value === 'function' || 'handleEvent' in value ? value : value.handler;
  const target = self ? el : binding.arg ? document.querySelector(binding.arg) : window;
  if (!target) return;
  target.addEventListener('scroll', handler, options);
  el._onScroll = {
    handler,
    options,
    // Don't reference self
    target: self ? undefined : target
  };
}

function scroll_unmounted(el) {
  if (!el._onScroll) return;
  const {
    handler,
    options,
    target = el
  } = el._onScroll;
  target.removeEventListener('scroll', handler, options);
  delete el._onScroll;
}

function scroll_updated(el, binding) {
  if (binding.value === binding.oldValue) return;
  scroll_unmounted(el);
  scroll_mounted(el, binding);
}

const Scroll = {
  mounted: scroll_mounted,
  unmounted: scroll_unmounted,
  updated: scroll_updated
};
/* harmony default export */ const directives_scroll = ((/* unused pure expression or super */ null && (Scroll)));
;// CONCATENATED MODULE: ./src/directives/touch/index.ts
// Types
// Utilities


const handleGesture = wrapper => {
  const {
    touchstartX,
    touchendX,
    touchstartY,
    touchendY
  } = wrapper;
  const dirRatio = 0.5;
  const minDistance = 16;
  wrapper.offsetX = touchendX - touchstartX;
  wrapper.offsetY = touchendY - touchstartY;

  if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
    wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
    wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
  }

  if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
    wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
    wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
  }
};

function touchstart(event, wrapper) {
  var _wrapper$start;

  const touch = event.changedTouches[0];
  wrapper.touchstartX = touch.clientX;
  wrapper.touchstartY = touch.clientY;
  (_wrapper$start = wrapper.start) == null ? void 0 : _wrapper$start.call(wrapper, { ...event,
    ...wrapper
  });
}

function touchend(event, wrapper) {
  var _wrapper$end;

  const touch = event.changedTouches[0];
  wrapper.touchendX = touch.clientX;
  wrapper.touchendY = touch.clientY;
  (_wrapper$end = wrapper.end) == null ? void 0 : _wrapper$end.call(wrapper, { ...event,
    ...wrapper
  });
  handleGesture(wrapper);
}

function touchmove(event, wrapper) {
  var _wrapper$move;

  const touch = event.changedTouches[0];
  wrapper.touchmoveX = touch.clientX;
  wrapper.touchmoveY = touch.clientY;
  (_wrapper$move = wrapper.move) == null ? void 0 : _wrapper$move.call(wrapper, { ...event,
    ...wrapper
  });
}

function createHandlers(value = {}) {
  const wrapper = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: value.left,
    right: value.right,
    up: value.up,
    down: value.down,
    start: value.start,
    move: value.move,
    end: value.end
  };
  return {
    touchstart: e => touchstart(e, wrapper),
    touchend: e => touchend(e, wrapper),
    touchmove: e => touchmove(e, wrapper)
  };
}

function touch_mounted(el, binding) {
  var _value$options, _binding$instance, _target$_touchHandler;

  const value = binding.value;
  const target = value != null && value.parent ? el.parentElement : el;
  const options = (_value$options = value == null ? void 0 : value.options) != null ? _value$options : {
    passive: true
  };
  const uid = (_binding$instance = binding.instance) == null ? void 0 : _binding$instance.$.uid; // TODO: use custom uid generator

  if (!target || !uid) return;
  const handlers = createHandlers(binding.value);
  target._touchHandlers = (_target$_touchHandler = target._touchHandlers) != null ? _target$_touchHandler : Object.create(null);
  target._touchHandlers[uid] = handlers;
  keys(handlers).forEach(eventName => {
    target.addEventListener(eventName, handlers[eventName], options);
  });
}

function touch_unmounted(el, binding) {
  var _binding$value, _binding$instance2;

  const target = (_binding$value = binding.value) != null && _binding$value.parent ? el.parentElement : el;
  const uid = (_binding$instance2 = binding.instance) == null ? void 0 : _binding$instance2.$.uid;
  if (!(target != null && target._touchHandlers) || !uid) return;
  const handlers = target._touchHandlers[uid];
  keys(handlers).forEach(eventName => {
    target.removeEventListener(eventName, handlers[eventName]);
  });
  delete target._touchHandlers[uid];
}

const Touch = {
  mounted: touch_mounted,
  unmounted: touch_unmounted
};
/* harmony default export */ const touch = ((/* unused pure expression or super */ null && (Touch)));
;// CONCATENATED MODULE: ./src/directives/index.ts
 // export { Color } from './color'

 // export { Mutate } from './mutate'





;// CONCATENATED MODULE: ./src/iconsets/mdi.ts
// Utilities
 // Components

 // Types

const aliases = {
  complete: 'mdi-check',
  cancel: 'mdi-close-circle',
  close: 'mdi-close',
  delete: 'mdi-close-circle',
  // delete (e.g. v-chip close)
  clear: 'mdi-close',
  success: 'mdi-check-circle',
  info: 'mdi-information',
  warning: 'mdi-alert-circle',
  error: 'mdi-close-circle',
  prev: 'mdi-chevron-left',
  next: 'mdi-chevron-right',
  checkboxOn: 'mdi-checkbox-marked',
  checkboxOff: 'mdi-checkbox-blank-outline',
  checkboxIndeterminate: 'mdi-minus-box',
  delimiter: 'mdi-circle',
  // for carousel
  sort: 'mdi-arrow-up',
  expand: 'mdi-chevron-down',
  menu: 'mdi-menu',
  subgroup: 'mdi-menu-down',
  dropdown: 'mdi-menu-down',
  radioOn: 'mdi-radiobox-marked',
  radioOff: 'mdi-radiobox-blank',
  edit: 'mdi-pencil',
  ratingEmpty: 'mdi-star-outline',
  ratingFull: 'mdi-star',
  ratingHalf: 'mdi-star-half-full',
  loading: 'mdi-cached',
  first: 'mdi-page-first',
  last: 'mdi-page-last',
  unfold: 'mdi-unfold-more-horizontal',
  file: 'mdi-paperclip',
  plus: 'mdi-plus',
  minus: 'mdi-minus'
};
const mdi = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: props => (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(VClassIcon, { ...props,
    class: 'mdi'
  })
};

;// CONCATENATED MODULE: ./src/framework.ts






 // Utilities


 // Types

const createVuetify = (options = {}) => {
  const install = app => {
    const {
      components = {},
      directives = {},
      icons = {}
    } = options;

    for (const key in directives) {
      const directive = directives[key];
      app.directive(key, directive);
    }

    for (const key in components) {
      const component = components[key];
      app.component(key, component);
    }

    app.provide(DefaultsSymbol, createDefaults(options.defaults));
    app.provide(DisplaySymbol, createDisplay(options.display));
    app.provide(ThemeSymbol, createTheme(options.theme));
    app.provide(IconSymbol, mergeDeep({
      defaultSet: 'mdi',
      sets: { ...defaultSets,
        mdi: mdi
      },
      aliases: aliases
    }, icons));
    const {
      adapter,
      rootInstance
    } = createLocaleAdapter(app, options == null ? void 0 : options.locale);
    app.provide(LocaleAdapterSymbol, adapter);
    app.provide(RtlSymbol, createRtl(rootInstance, options == null ? void 0 : options.locale)); // Vue's inject() can only be used in setup

    function inject(key) {
      var _vm$parent$provides, _vm$parent, _vm$vnode$appContext;

      const vm = this.$;
      const provides = (_vm$parent$provides = (_vm$parent = vm.parent) == null ? void 0 : _vm$parent.provides) != null ? _vm$parent$provides : (_vm$vnode$appContext = vm.vnode.appContext) == null ? void 0 : _vm$vnode$appContext.provides;

      if (provides && key in provides) {
        return provides[key];
      }
    }

    app.mixin({
      computed: {
        $vuetify() {
          return (0,external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.reactive)({
            defaults: inject.call(this, DefaultsSymbol),
            display: inject.call(this, DisplaySymbol),
            theme: inject.call(this, ThemeSymbol),
            icons: inject.call(this, IconSymbol),
            locale: inject.call(this, LocaleAdapterSymbol),
            rtl: inject.call(this, RtlSymbol)
          });
        }

      }
    });
  };

  return {
    install
  };
};
;// CONCATENATED MODULE: ./src/entry-bundler.ts




const entry_bundler_createVuetify = (options = {}) => {
  return createVuetify({
    components: components_namespaceObject,
    directives: directives_namespaceObject,
    ...options
  });
};
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=vuetify.min.js.map