import { withDirectives as _withDirectives, resolveDirective as _resolveDirective, vShow as _vShow, Fragment as _Fragment, createVNode as _createVNode, mergeProps as _mergeProps } from "vue";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Styles
import "./VOverlay.sass"; // Composables

import { makeThemeProps, useTheme } from "../../composables/theme.mjs";
import { makeTransitionProps, MaybeTransition } from "../../composables/transition.mjs";
import { useBackButton } from "../../composables/router.mjs";
import { useBackgroundColor } from "../../composables/color.mjs";
import { useProxiedModel } from "../../composables/proxiedModel.mjs";
import { useRtl } from "../../composables/rtl.mjs";
import { useTeleport } from "../../composables/teleport.mjs"; // Directives

import { ClickOutside } from "../../directives/click-outside/index.mjs"; // Utilities

import { convertToUnit, defineComponent, getScrollParent, getScrollParents, standardEasing, useRender } from "../../util/index.mjs";
import { computed, nextTick, ref, Teleport, toRef, Transition, watch, watchEffect } from 'vue'; // Types

function useBooted(isActive, eager) {
  const isBooted = ref(eager.value);
  watchEffect(() => {
    if (eager.value || isActive.value) {
      isBooted.value = true;
    }
  });
  return {
    isBooted
  };
}

const positionStrategies = ['global', // specific viewport position, usually centered
'connected', // connected to a certain element
'flexible' // connected to an element with the ability to overflow or shift if it doesn't fit in the screen
];
const scrollStrategies = ['close', 'block', 'reposition'];

function Scrim(props) {
  const {
    modelValue,
    color,
    ...rest
  } = props;
  return _createVNode(Transition, {
    "name": "fade-transition",
    "appear": true
  }, {
    default: () => [props.modelValue && _createVNode("div", _mergeProps({
      "class": ['v-overlay__scrim', props.color.backgroundColorClasses.value],
      "style": props.color.backgroundColorStyles.value
    }, rest), null, 16)]
  }, 8, ["appear"]);
}

class CloseScrollStrategy {
  constructor({
    content,
    isActive
  }) {
    _defineProperty(this, "scrollElements", []);

    this.content = content;
    this.isActive = isActive;
  }

  enable() {
    this.scrollElements = [document, ...getScrollParents(this.content.value)];
    this.scrollElements.forEach(el => {
      el.addEventListener('scroll', this.onScroll.bind(this), {
        passive: true
      });
    });
  }

  disable() {
    this.scrollElements.forEach(el => {
      el.removeEventListener('scroll', this.onScroll.bind(this));
    });
  }

  onScroll() {
    this.isActive.value = false;
  }

}

class BlockScrollStrategy {
  constructor({
    content
  }) {
    _defineProperty(this, "initialOverflow", []);

    _defineProperty(this, "scrollElements", []);

    this.content = content;
  }

  enable() {
    this.scrollElements = getScrollParents(this.content.value);
    const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
    document.documentElement.style.setProperty('--v-scrollbar-offset', convertToUnit(scrollbarWidth));
    this.scrollElements.forEach((el, i) => {
      this.initialOverflow[i] = el.style.overflowY;
      el.style.overflowY = 'hidden';
      el.style.setProperty('--v-scrollbar-offset', convertToUnit(scrollbarWidth));
    });
  }

  disable() {
    this.scrollElements.forEach((el, i) => {
      el.style.overflowY = this.initialOverflow[i];
      el.style.removeProperty('--v-scrollbar-offset');
    });
    document.documentElement.style.removeProperty('--v-scrollbar-offset');
  }

}

export default defineComponent({
  name: 'VOverlay',
  directives: {
    ClickOutside
  },
  inheritAttrs: false,
  props: {
    absolute: Boolean,
    attach: {
      type: [Boolean, String, Object],
      default: 'body'
    },
    eager: Boolean,
    noClickAnimation: Boolean,
    modelValue: Boolean,
    origin: [String, Object],
    persistent: Boolean,
    positionStrategy: {
      type: String,
      default: 'global',
      validator: val => positionStrategies.includes(val)
    },
    scrim: {
      type: [String, Boolean],
      default: true
    },
    scrollStrategy: {
      type: String,
      default: 'block',
      validator: val => scrollStrategies.includes(val)
    },
    ...makeThemeProps(),
    ...makeTransitionProps()
  },
  emits: {
    'click:outside': e => true,
    'update:modelValue': value => true
  },

  setup(props, {
    slots,
    attrs,
    emit
  }) {
    const isActive = useProxiedModel(props, 'modelValue');
    const {
      teleportTarget
    } = useTeleport(toRef(props, 'attach'));
    const {
      themeClasses
    } = useTheme(props);
    const {
      rtlClasses
    } = useRtl();
    const {
      isBooted
    } = useBooted(isActive, toRef(props, 'eager'));
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props.scrim === 'string' ? props.scrim : null;
    }));

    function onClickOutside(e) {
      emit('click:outside', e);
      if (!props.persistent) isActive.value = false;else animateClick();
    }

    function closeConditional() {
      return isActive.value;
    }

    const activatorElement = ref();

    function onActivatorClick(e) {
      activatorElement.value = e.currentTarget || e.target;
      isActive.value = !isActive.value;
    }

    function onKeydown(e) {
      if (e.key === 'Escape') {
        if (!props.persistent) {
          isActive.value = false;
        } else animateClick();
      }
    }

    useBackButton(next => {
      next(!isActive.value);
      if (!props.persistent) isActive.value = false;else animateClick();
    });
    const content = ref();
    watch(isActive, val => {
      nextTick(() => {
        if (val) {
          var _content$value;

          (_content$value = content.value) == null ? void 0 : _content$value.focus();
        } else {
          var _activatorElement$val;

          (_activatorElement$val = activatorElement.value) == null ? void 0 : _activatorElement$val.focus();
        }
      });
    });
    const root = ref();
    const top = ref();
    watch(() => isActive.value && props.absolute && teleportTarget.value == null, val => {
      if (val) {
        const scrollParent = getScrollParent(root.value);

        if (scrollParent && scrollParent !== document.scrollingElement) {
          top.value = scrollParent.scrollTop;
        }
      }
    }); // Add a quick "bounce" animation to the content

    function animateClick() {
      var _content$value2;

      if (props.noClickAnimation) return;
      (_content$value2 = content.value) == null ? void 0 : _content$value2.animate([{
        transformOrigin: 'center'
      }, {
        transform: 'scale(1.03)'
      }, {
        transformOrigin: 'center'
      }], {
        duration: 150,
        easing: standardEasing
      });
    }

    function onAfterLeave() {
      if (!props.eager) isBooted.value = false;
    }

    const scrollStrategy = props.scrollStrategy === 'close' ? new CloseScrollStrategy({
      content,
      isActive
    }) : props.scrollStrategy === 'block' ? new BlockScrollStrategy({
      content
    }) : null; // TODO: reactive

    if (scrollStrategy) {
      watch(isActive, val => {
        nextTick(() => {
          val ? scrollStrategy.enable() : scrollStrategy.disable();
        });
      });
    }

    useRender(() => {
      var _slots$activator, _slots$default;

      return _createVNode(_Fragment, null, [(_slots$activator = slots.activator) == null ? void 0 : _slots$activator.call(slots, {
        isActive: isActive.value,
        props: {
          modelValue: isActive.value,
          'onUpdate:modelValue': val => isActive.value = val,
          onClick: onActivatorClick
        }
      }), _createVNode(Teleport, {
        "disabled": !teleportTarget.value,
        "ref": root,
        "to": teleportTarget.value
      }, {
        default: () => [isBooted.value && _createVNode("div", _mergeProps({
          "class": ['v-overlay', {
            'v-overlay--absolute': props.absolute,
            'v-overlay--active': isActive.value
          }, themeClasses.value, rtlClasses.value],
          "style": top.value != null ? `top: ${convertToUnit(top.value)}` : undefined
        }, attrs), [_createVNode(Scrim, {
          "color": scrimColor,
          "modelValue": isActive.value && !!props.scrim
        }, null, 8, ["color", "modelValue"]), _createVNode(MaybeTransition, {
          "appear": true,
          "onAfterLeave": onAfterLeave,
          "persisted": true,
          "transition": props.transition
        }, {
          default: () => [_withDirectives(_createVNode("div", {
            "ref": content,
            "class": "v-overlay__content",
            "tabindex": -1,
            "onKeydown": onKeydown
          }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
            isActive
          })], 40, ["tabindex", "onKeydown"]), [[_vShow, isActive.value], [_resolveDirective("click-outside"), {
            handler: onClickOutside,
            closeConditional
          }]])]
        }, 8, ["appear", "onAfterLeave", "persisted", "transition"])], 16)]
      }, 8, ["disabled", "to"])]);
    });
    return {
      animateClick,
      content
    };
  }

});
//# sourceMappingURL=VOverlay.mjs.map